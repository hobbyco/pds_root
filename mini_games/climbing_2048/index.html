<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë³¼ë”ë§ 2048 - í´ë¼ì´ë° 2048 ê²Œì„</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="í´ë¼ì´ë° í…Œë§ˆì˜ 2048 í¼ì¦ ê²Œì„, ë³¼ë”ë§ 2048! V0ë¶€í„° V7+ê¹Œì§€ í´ë¼ì´ë° ê·¸ë ˆì´ë“œë¥¼ í•©ì¹˜ê³  4ê°€ì§€ ìŠ¤í‚¬ì„ ëª¨ì•„ ë³¼ë”ë§ ë§ˆìŠ¤í„°ê°€ ë˜ì–´ë³´ì„¸ìš”.">
    <meta name="keywords" content="2048, í´ë¼ì´ë°, ë³¼ë”ë§, í¼ì¦ ê²Œì„, ì›¹ê²Œì„, 2048 ê²Œì„, climbing, bouldering, puzzle game">
    
    <!-- Open Graph Meta Tags for Social Media -->
    <meta property="og:title" content="ë³¼ë”ë§ 2048 - í´ë¼ì´ë° 2048 ê²Œì„">
    <meta property="og:description" content="V0ë¶€í„° V7+ê¹Œì§€ í´ë¼ì´ë° ê·¸ë ˆì´ë“œë¥¼ í•©ì³ ë³¼ë”ë§ ë§ˆìŠ¤í„°ì— ë„ì „í•˜ì„¸ìš”!">
    <meta property="og:type" content="website">
    <meta property="og:url" content=""> <!-- ì‹¤ì œ ê²Œì„ URLì„ ì—¬ê¸°ì— ì…ë ¥í•˜ì„¸ìš” -->
    <meta property="og:image" content=""> <!-- ê²Œì„ ë¯¸ë¦¬ë³´ê¸° ì´ë¯¸ì§€ URLì„ ì—¬ê¸°ì— ì…ë ¥í•˜ì„¸ìš” -->

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KFCTS5DZ6V"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-KFCTS5DZ6V');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif; /* í°íŠ¸ë¥¼ ì¢€ ë” ë¶€ë“œëŸ½ê²Œ ë³€ê²½ */
            background: #f0f2f5; /* ë°ì€ íšŒìƒ‰ ë°°ê²½ */
            color: #333; /* ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒì„ ì–´ë‘¡ê²Œ */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        /* ì˜¤í”„ë‹í™”ë©´ ìŠ¤íƒ€ì¼ */
        .opening-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e6f7ff 0%, #ffffff 100%); /* ë¶€ë“œëŸ½ê³  ë°ì€ ê·¸ë¼ë°ì´ì…˜ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: openingFadeIn 1s ease-in-out;
        }

        .opening-screen.hidden {
            display: none;
        }

        .opening-container {
            background: #ffffff; /* í°ìƒ‰ ë°°ê²½ */
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1); /* ë¶€ë“œëŸ¬ìš´ ê·¸ë¦¼ì */
            border: 1px solid #e0e0e0;
            max-width: 400px;
            width: 90%;
            animation: openingSlideUp 0.8s ease-out 0.2s both;
        }

        .opening-title {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .climbing-icon {
            font-size: 3em;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border-radius: 15px;
            padding: 15px;
            color: white; /* ì•„ì´ì½˜ ìƒ‰ìƒ ì¶”ê°€ */
            box-shadow: 0 10px 25px rgba(254, 202, 87, 0.3);
        }

        .title-text {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #4a4a4a, #212121); /* ì‹¬í”Œí•˜ê³  ê°•ë ¬í•œ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none; /* í…ìŠ¤íŠ¸ ê·¸ë¦¼ì ì œê±° */
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.1em;
            margin-bottom: 30px;
            color: #555; /* ì–´ë‘ìš´ íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½ */
            font-weight: normal;
        }

        .best-score-display {
            background: #f7f9fa; /* ë°ì€ íšŒìƒ‰ ë°°ê²½ */
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid #e0e6ed;
        }

        .best-score-label {
            font-size: 0.9em;
            color: #6c757d; /* íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½ */
            margin-bottom: 5px;
        }

        .best-score-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff; /* í¬ì¸íŠ¸ íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
            text-shadow: none;
        }

        .opening-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }

        .bonus-card-toggle {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 5px 0;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            color: #333; /* ì–´ë‘ìš´ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
            font-size: 1em;
            font-weight: 500;
        }

        .checkbox-container input {
            display: none;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            background: #e0e6ed;
            border: 2px solid #ced4da;
            border-radius: 4px;
            margin-right: 10px;
            position: relative;
            transition: all 0.3s ease;
        }

        .checkbox-container input:checked + .checkmark {
            background: #007bff; /* íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
            border-color: #0069d9;
        }

        .checkbox-container input:checked + .checkmark::after {
            content: 'âœ“';
            position: absolute;
            left: 3px;
            top: -2px;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .checkbox-text {
            font-size: 0.95em;
        }

        .opening-btn {
            background: linear-gradient(135deg, #007bff, #0056b3); /* ë°ê³  ì‹¬í”Œí•œ íŒŒë€ìƒ‰ ë²„íŠ¼ */
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px; /* ë‘¥ê¸€ê²Œ ë³€ê²½ */
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 123, 255, 0.2); /* ê·¸ë¦¼ì ì•½í•˜ê²Œ */
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .opening-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 123, 255, 0.3);
        }

        .opening-btn.secondary {
            background: #6c757d; /* íšŒìƒ‰ ë²„íŠ¼ */
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.2);
        }

        .opening-btn.secondary:hover {
            box-shadow: 0 12px 35px rgba(108, 117, 125, 0.3);
        }

        @keyframes openingFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes openingSlideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* ê°€ì´ë“œ í™”ë©´ ìŠ¤íƒ€ì¼ */
        .guide-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e6f7ff 0%, #ffffff 100%); /* ì˜¤í”„ë‹ê³¼ ë™ì¼í•˜ê²Œ */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            overflow-y: auto;
        }

        .guide-container {
            background: #ffffff;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .guide-title {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .guide-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .guide-content {
            text-align: left;
        }

        .guide-section {
            background: #f8f9fa; /* ë°ì€ íšŒìƒ‰ */
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .guide-section h3 {
            color: #007bff; /* íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
        }

        .guide-section p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #495057;
            font-size: 0.95em;
        }

        /* ê²Œì„ ì»¨í…Œì´ë„ˆ */
        .game-container {
            text-align: center;
            background: #ffffff; /* í°ìƒ‰ ë°°ê²½ */
            border-radius: 20px;
            padding: 20px; /* íŒ¨ë”© ì¦ê°€ */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            position: relative;
            max-width: 400px; /* ìµœëŒ€ ë„ˆë¹„ ì¦ê°€ */
            width: 100%;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.5s ease;
        }

        .game-container.show {
            opacity: 1;
            transform: translateY(0);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 15px; /* ë§ˆì§„ ì¦ê°€ */
            color: #343a40; /* ì–´ë‘ìš´ ìƒ‰ìœ¼ë¡œ */
            text-shadow: none;
            letter-spacing: 1px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa; /* ë°ì€ íšŒìƒ‰ */
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 0.8em;
            margin-bottom: 3px;
            color: #6c757d;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #343a40;
        }

        .skills-container {
            background: #f8f9fa; /* ë°ì€ íšŒìƒ‰ */
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
        }

        .skills-title {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #f39c12;
            font-weight: bold;
        }

        .skills-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .skill-slot {
            background: #e9ecef; /* ë” ë°ì€ íšŒìƒ‰ */
            border: 2px dashed #ced4da; /* íšŒìƒ‰ ì ì„  */
            border-radius: 10px;
            padding: 10px 5px;
            min-height: 55px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            color: #6c757d;
        }

        .skill-slot.acquired {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            border: 2px solid #27ae60;
            color: white;
            font-weight: bold;
            animation: skillGlow 2s infinite alternate;
        }

        @keyframes skillGlow {
            0% { box-shadow: 0 0 5px rgba(39, 174, 96, 0.5); }
            100% { box-shadow: 0 0 20px rgba(39, 174, 96, 0.8); }
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px; /* ê°„ê²© ì¦ê°€ */
            background: #e9ecef; /* ë°ì€ íšŒìƒ‰ */
            padding: 15px; /* íŒ¨ë”© ì¦ê°€ */
            border-radius: 15px;
            margin: 15px 0;
            border: 1px solid #dee2e6;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05); /* ê·¸ë¦¼ì ì•½í•˜ê²Œ */
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .tile {
            width: auto; /* ìë™ ë„ˆë¹„ */
            aspect-ratio: 1 / 1; /* 1:1 ë¹„ìœ¨ ìœ ì§€ */
            height: auto;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); /* ê·¸ë¦¼ì ì•½ê°„ ì•½í•˜ê²Œ */
            transition: all 0.2s ease-in-out;
            border: none; /* í…Œë‘ë¦¬ ì œê±° */
            position: relative;
            cursor: pointer;
        }

        .tile.moving {
            transition: transform 0.3s ease-in-out;
        }

        .tile.new-tile {
            position: relative;
            animation: tileAppear 0.4s ease-out;
        }

        .tile.new-tile::before {
            content: 'N';
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 3px;
            padding: 1px 3px;
            font-size: 0.6em;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
        }

        @keyframes tileAppear {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .tile.merging {
            animation: tileMerge 0.3s ease-out;
        }

        @keyframes tileMerge {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            }
            100% {
                transform: scale(1);
            }
        }

        .tile.empty {
            background: #d6dbe0; /* ë¹ˆ íƒ€ì¼ ìƒ‰ìƒ ë³€ê²½ */
            border: 2px dashed #b8c0c8;
        }

        .tile.clickable {
            cursor: pointer;
            border: 3px solid #feca57;
            animation: clickablePulse 1s infinite;
        }

        @keyframes clickablePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .tile.crux {
            background: linear-gradient(135deg, #6c757d, #343a40) !important; /* ì–´ë‘ìš´ íšŒìƒ‰ í¬ëŸ­ìŠ¤ */
            border: 3px solid #495057 !important;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .tile.crux .crux-icon {
            font-size: 1.8em;
            margin-bottom: 2px;
        }

        .tile.crux .crux-counter {
            font-size: 0.7em;
            color: #feca57;
            background: rgba(0, 0, 0, 0.7); /* ë°°ê²½ì€ ìœ ì§€ */
            border-radius: 8px;
            padding: 2px 6px;
            font-weight: bold;
        }

        /* ë³¼ë”ë§ ê·¸ë ˆì´ë“œ ìƒ‰ìƒ */
        .tile.v0 { 
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            color: white; /* í…ìŠ¤íŠ¸ ìƒ‰ìƒ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
        }
        .tile.v1 { 
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }
        .tile.v2 { 
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            box-shadow: 0 4px 15px rgba(241, 196, 15, 0.3);
        }
        .tile.v3 { 
            background: linear-gradient(135deg, #27ae60, #229954);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }
        .tile.v4 { 
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            color: white;
        }
        .tile.v5 { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        .tile.v6 { 
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
            color: white;
        }
        .tile.v7 { 
            background: linear-gradient(135deg, #2c3e50, #34495e);
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.3);
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-grip { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #e74c3c);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-core { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #f39c12);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-dynamic { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #27ae60);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-balance { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #3498db);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        @keyframes skillPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(44, 62, 80, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 25px rgba(44, 62, 80, 0.8);
            }
        }


        .controls {
            margin: 25px 0 10px 0; /* ë§ˆì§„ ì¡°ì • */
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            background: #6c757d; /* íšŒìƒ‰ ë²„íŠ¼ */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px; /* ë‘¥ê¸€ê²Œ */
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 80px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            user-select: none;
            -webkit-user-select: none;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            background: #5a6268;
        }
        
        /* 'ìƒˆ ê²Œì„' ë²„íŠ¼ì„ íŒŒë€ìƒ‰ìœ¼ë¡œ ê°•ì¡° */
        .controls .btn:first-child {
            background: #007bff;
        }
        .controls .btn:first-child:hover {
            background: #0069d9;
        }

        .btn.shuffle-btn {
            background: #9b59b6;
            font-size: 1.2em;
            padding: 10px 20px;
        }

        .btn.shuffle-btn:hover {
            background: #8e44ad;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7); /* ë°°ê²½ ì–´ë‘¡ê²Œ */
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-content {
            background: #ffffff; /* í°ìƒ‰ ë°°ê²½ */
            color: #333; /* ì–´ë‘ìš´ í…ìŠ¤íŠ¸ */
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            border: none;
            max-width: 400px;
        }
        
        #game-over-title {
            color: #007bff;
        }

        .achievement-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            padding: 15px 25px;
            border-radius: 50px; /* ë‘¥ê¸€ê²Œ */
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 100;
            border: none;
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .achievement-display.show {
            opacity: 1;
            animation: achievementShow 3s ease;
        }

        @keyframes achievementShow {
            0% { 
                transform: translateX(100px) scale(0.8); 
                opacity: 0; 
            }
            20%, 80% { 
                transform: translateX(0) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translateX(100px) scale(0.8); 
                opacity: 0; 
            }
        }

        /* ë³´ë„ˆìŠ¤ ì¹´ë“œ í‘œì‹œ */
        .bonus-card-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            z-index: 1500;
            height: 100%;
            pointer-events: none;
        }

        .bonus-card-content {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            border: none;
            max-width: 350px;
            width: 90%;
            animation: cardSlideDown 0.5s ease;
            color: white;
            pointer-events: auto;
        }

        @keyframes cardSlideDown {
            from { 
                transform: translateY(-50px) scale(0.8);
                opacity: 0;
            }
            to { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .bonus-card-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .bonus-card-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff; /* í°ìƒ‰, ê·¸ë¦¼ì ì¶”ê°€ */
            text-shadow: 1px 1px 5px rgba(0,0,0,0.2);
        }

        .bonus-card-description {
            font-size: 1em;
            margin-bottom: 20px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }

        .bonus-card-question {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }

        .bonus-card-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .bonus-card-actions .btn {
            padding: 10px 20px;
            font-size: 0.9em;
            min-width: 60px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.7em;
            z-index: 1000;
            display: none;
        }

        @media (max-width: 768px) {
            .guide-container {
                padding: 25px;
                margin: 10px;
            }
            
            .guide-section {
                padding: 15px;
            }
            .game-container {
                padding: 15px;
            }
            .game-board {
                gap: 8px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- ì˜¤í”„ë‹í™”ë©´ -->
    <div class="opening-screen" id="opening-screen">
        <div class="opening-container">
            <div class="opening-title">
                <div class="climbing-icon">ğŸ§—â€â™‚ï¸</div>
                <div class="title-text">ë³¼ë”ë§ 2048</div>
            </div>
            
            <div class="subtitle">í´ë¼ì´ë° ê·¸ë ˆì´ë“œë¥¼ ì •ë³µí•˜ë¼!</div>
            
            <div class="best-score-display">
                <div class="best-score-label">ìµœê³  ì ìˆ˜</div>
                <div class="best-score-value" id="opening-best-score">0</div>
            </div>
            
            <div class="opening-buttons">
                <button class="opening-btn" onclick="gameStart()">
                    ğŸ¯ ìƒˆ ê²Œì„ ì‹œì‘
                </button>
                
                <div class="bonus-card-toggle">
                    <label class="checkbox-container">
                        <input type="checkbox" id="bonus-card-enabled" checked>
                        <span class="checkmark"></span>
                        <span class="checkbox-text">ë³´ë„ˆìŠ¤ ì¹´ë“œ ë“±ì¥</span>
                    </label>
                </div>
                
                <button class="opening-btn secondary" onclick="guideShow()">
                    ğŸ“– ê°€ì´ë“œ ë³´ê¸°
								</button>
								
								 <!-- í‘¸í„°ê°€ ì‚½ì…ë  ìœ„ì¹˜ -->
					<div id="footer-placeholder"></div>

					<script>
						// ê³µí†µ í‘¸í„° ì‚½ì…
						// mini_games í´ë” ì•ˆì— ìˆìœ¼ë¯€ë¡œ, ìƒìœ„ í´ë”ì˜ footer.htmlì„ ì°¸ì¡°í•˜ê¸° ìœ„í•´ ../ ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
						fetch('/../../footer.html')
							.then(response => {
								if (!response.ok) {
									throw new Error('ë„¤íŠ¸ì›Œí¬ ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: ' + response.statusText);
								}
								return response.text();
							})
							.then(data => {
								const placeholder = document.getElementById('footer-placeholder');
								if (placeholder) {
									placeholder.innerHTML = data;
									// í‘¸í„°ì— ìˆëŠ” Lucide ì•„ì´ì½˜ì„ ë Œë”ë§í•˜ê¸° ìœ„í•´ í•¨ìˆ˜ë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•©ë‹ˆë‹¤.
									if (typeof lucide !== 'undefined') {
										lucide.createIcons();
									}
								}
							})
							.catch(error => {
								console.error('í‘¸í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:', error);
								const placeholder = document.getElementById('footer-placeholder');
								if (placeholder) {
									placeholder.innerHTML = '<p class="text-center text-red-500 py-10">í‘¸í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë¡œì»¬ í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸í•˜ëŠ” ê²½ìš° ë¸Œë¼ìš°ì € ë³´ì•ˆ ì •ì±…(CORS) ë•Œë¬¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>';
								}
							});

						// í˜ì´ì§€ì˜ ë‚˜ë¨¸ì§€ Lucide ì•„ì´ì½˜ì„ ë Œë”ë§í•©ë‹ˆë‹¤.
						if (typeof lucide !== 'undefined') {
							lucide.createIcons();
						}
					</script>



            </div>
        </div>
    </div>

    <!-- ê°€ì´ë“œ í™”ë©´ -->
    <div class="guide-screen" id="guide-screen">
        <div class="guide-container">
            <div class="guide-title">
                <div class="climbing-icon">ğŸ§—â€â™‚ï¸</div>
                <div class="title-text">í´ë¼ì´ë° ê°€ì´ë“œ</div>
            </div>
            
            <div class="guide-buttons">
                <button class="opening-btn" onclick="gameStart()">
                    ğŸ¯ ê²Œì„ ì‹œì‘í•˜ê¸°
                </button>
                <button class="opening-btn secondary" onclick="mainMenuShow()">
                    ğŸ  ë©”ì¸ë©”ë‰´ ê°€ê¸°
                </button>
            </div>
            
            <div class="guide-content">
                <div class="guide-section">
                    <h3>ğŸ® ì¡°ì‘ë²•</h3>
                    <p><strong>í™”ì‚´í‘œ í‚¤</strong>, <strong>WASD</strong> ë˜ëŠ” <strong>ìŠ¤ì™€ì´í”„</strong>ë¡œ í™€ë“œë¥¼ ì›€ì§ì´ì„¸ìš”</p>
                    <p><strong>ê°™ì€ ê·¸ë ˆì´ë“œ</strong>ë¥¼ í•©ì³ì„œ <strong>ìƒìœ„ ê·¸ë ˆì´ë“œ</strong>ë¡œ ì—…ê·¸ë ˆì´ë“œí•˜ì„¸ìš”</p>
                    <p><strong>V0</strong> â†’ <strong>V1</strong> â†’ <strong>V2</strong> â†’ <strong>V3</strong> â†’ <strong>V4</strong> â†’ <strong>V5</strong> â†’ <strong>V6</strong> â†’ <strong>V7+</strong></p>
                </div>
                
                <div class="guide-section">
                    <h3>ğŸ† ëª©í‘œ</h3>
                    <p><strong>V7+</strong>ë¥¼ ë§Œë“¤ë©´ ìˆœì„œëŒ€ë¡œ <strong>ìŠ¤í‚¬</strong>ì„ íšë“í•©ë‹ˆë‹¤</p>
                    <p><strong>ğŸ’ª ê·¸ë¦½ë ¥</strong> â†’ <strong>ğŸ‹ï¸ ì½”ì–´</strong> â†’ <strong>ğŸš€ ë‹¤ì´ë‚˜ë¯¹</strong> â†’ <strong>âš–ï¸ ë°¸ëŸ°ìŠ¤</strong></p>
                    <p><strong>4ê°€ì§€ ìŠ¤í‚¬</strong>ì„ ëª¨ë‘ ìˆ˜ì§‘í•˜ë©´ <strong>í´ë¼ì´ë° ë§ˆìŠ¤í„°</strong>!</p>
                </div>
                
                <div class="guide-section">
                    <h3>ğŸ ë³´ë„ˆìŠ¤ ì¹´ë“œ (10ë²ˆ ì›€ì§ì¼ ë•Œë§ˆë‹¤)</h3>
                    <p><strong>ğŸ§—â€â™‚ï¸ ë³´ë„ˆìŠ¤ í™€ë“œ:</strong> V5 íƒ€ì¼ì´ ë¬´ì‘ìœ„ ìœ„ì¹˜ì— ìƒì„±</p>
                    <p><strong>ğŸ—‘ï¸ í™€ë“œ(íƒ€ì¼) ì‚­ì œ:</strong> ë§ˆìŒì— ì•ˆ ë“œëŠ” í™€ë“œë¥¼ ì‚­ì œ</p>
                    <p><strong>ğŸ² ë¬´ì‘ìœ„ ì¬ë°°ì¹˜:</strong> ëª¨ë“  íƒ€ì¼ì„ ì„ì–´ì„œ ì¬ë°°ì¹˜</p>
                    <p><strong>ğŸª¨ í¬ëŸ­ìŠ¤:</strong> 3í„´ê°„ ì›€ì§ì´ì§€ ì•ŠëŠ” ë°”ìœ„ ìƒì„±</p>
                </div>
                
                <div class="guide-section">
                    <h3>ğŸ¯ íŒ</h3>
                    <p>ì—°ì†ìœ¼ë¡œ í•©ì¹˜ë©´ <strong>ì½¤ë³´ ë³´ë„ˆìŠ¤</strong>ë¥¼ íšë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
                    <p>ìŠ¤í‚¬ íƒ€ì¼ì€ íŠ¹ë³„í•œ <strong>ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼</strong>ë¡œ í‘œì‹œë©ë‹ˆë‹¤</p>
                    <p>ë³´ë„ˆìŠ¤ ì¹´ë“œëŠ” ì„ íƒì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
                    <p>ì „ëµì ìœ¼ë¡œ ì›€ì§ì—¬ì„œ <strong>ìµœê³  ì ìˆ˜</strong>ì— ë„ì „í•´ë³´ì„¸ìš”!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ ê²Œì„ í™”ë©´ -->
    <div class="game-container" id="game-container">
        <!-- ë³´ë„ˆìŠ¤ ì¹´ë“œ ë°›ê¸° í™”ë©´ (1ë‹¨ê³„) -->
        <div class="bonus-card-display" id="bonus-card-receive">
            <div class="bonus-card-content">
                <div class="bonus-card-icon">ğŸ</div>
                <div class="bonus-card-title">ë³´ë„ˆìŠ¤ ì¹´ë“œ íšë“!</div>
                <div class="bonus-card-description">10í„´ë§ˆë‹¤ ë°›ëŠ” íŠ¹ë³„í•œ ë³´ë„ˆìŠ¤ ì¹´ë“œì…ë‹ˆë‹¤!</div>
                <div class="bonus-card-question">ì¹´ë“œë¥¼ ì—´ì–´ë³´ì‹œê² ìŠµë‹ˆê¹Œ?</div>
                <div class="bonus-card-actions">
                    <button class="btn" onclick="bonusCardOpen()" style="background: linear-gradient(135deg, #27ae60, #2ecc71);">ì¹´ë“œ ì—´ê¸°</button>
                    <button class="btn" onclick="bonusCardDiscard()" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">ë²„ë¦¬ê¸°</button>
                </div>
            </div>
        </div>

        <!-- ë³´ë„ˆìŠ¤ ì¹´ë“œ ì‚¬ìš© í™•ì¸ í™”ë©´ (2ë‹¨ê³„) -->
        <div class="bonus-card-display" id="bonus-card-confirm">
            <div class="bonus-card-content">
                <div class="bonus-card-icon" id="bonus-card-icon">ğŸ</div>
                <div class="bonus-card-title" id="bonus-card-title">ë³´ë„ˆìŠ¤ ì¹´ë“œ!</div>
                <div class="bonus-card-description" id="bonus-card-description">ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤!</div>
                <div class="bonus-card-question" id="bonus-card-question">ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
                <div class="bonus-card-actions" id="bonus-card-actions">
                    <button class="btn" onclick="bonusConfirm()" style="background: linear-gradient(135deg, #27ae60, #2ecc71);">ì˜ˆ</button>
                    <button class="btn" onclick="bonusDecline()" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">ì•„ë‹ˆì˜¤</button>
                </div>
            </div>
        </div>

        <!-- íƒ€ì¼ ì‚­ì œ ë©”ì‹œì§€ (ê²Œì„ ìƒë‹¨ì— ìœ„ì¹˜) -->
        <div class="bonus-card-display" id="tile-delete-mode" style="display: none;">
            <div class="bonus-card-content" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);">
                <div class="bonus-card-icon" style="color: #d63384;">ğŸ—‘ï¸</div>
                <div class="bonus-card-title" style="color: #d63384;">íƒ€ì¼ ì‚­ì œ</div>
                <div class="bonus-card-description" style="color: #333;">ì–´ëŠ íƒ€ì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>ì‚­ì œí•  íƒ€ì¼ì„ í´ë¦­í•´ì£¼ì„¸ìš”.</div>
                <div class="bonus-card-actions">
                    <button class="btn" onclick="tileDeleteCancel()">ì·¨ì†Œ</button>
                </div>
            </div>
        </div>

        <h1>ğŸ§—â€â™‚ï¸ Boulder Master</h1>
        
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">ì ìˆ˜</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ìµœê³  ì ìˆ˜</div>
                <div class="stat-value" id="best-score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ì›€ì§ì„</div>
                <div class="stat-value" id="move-count">0</div>
            </div>
        </div>

        <div class="skills-container">
            <div class="skills-title">ğŸ¯ í´ë¼ì´ë° ìŠ¤í‚¬ ìˆ˜ì§‘</div>
            <div class="skills-grid">
                <div class="skill-slot" id="skill-grip">
                    <div>ğŸ’ª</div>
                    <div>ê·¸ë¦½ë ¥</div>
                </div>
                <div class="skill-slot" id="skill-core">
                    <div>ğŸ‹ï¸</div>
                    <div>ì½”ì–´</div>
                </div>
                <div class="skill-slot" id="skill-dynamic">
                    <div>ğŸš€</div>
                    <div>ë‹¤ì´ë‚˜ë¯¹</div>
                </div>
                <div class="skill-slot" id="skill-balance">
                    <div>âš–ï¸</div>
                    <div>ë°¸ëŸ°ìŠ¤</div>
                </div>
            </div>
        </div>

        <div class="game-board" id="game-board">
            <!-- íƒ€ì¼ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
        </div>

        <div class="controls">
            <button class="btn" onclick="gameNew()">ìƒˆ ê²Œì„</button>
            <button class="btn" onclick="mainMenuShow()">ë©”ì¸ ë©”ë‰´</button>
            <button class="btn shuffle-btn" id="shuffle-btn" onclick="tilesShuffleFunc()" style="display: none;">ğŸ²</button>
        </div>
    </div>

    <div class="game-over" id="game-over">
        <div class="game-over-content">
            <h2 id="game-over-title">ì„¸ì…˜ ì¢…ë£Œ!</h2>
            <p id="game-over-message"></p>
            <p>ì ìˆ˜: <span id="final-score"></span></p>
            <button class="btn" onclick="gameNew()" style="background: #007bff;">ë‹¤ì‹œ ë„ì „</button>
            <button class="btn" onclick="mainMenuShow()">ë©”ì¸ í™”ë©´</button>
        </div>
    </div>

    <div class="achievement-display" id="achievement-display"></div>

    <script>
        // ìŠ¤í¬ë¦½íŠ¸ ë¶€ë¶„ì€ ìˆ˜ì •í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
        // GAME CONSTANTS
        const GAME_CONFIG = {
            BOARD_SIZE: 4,
            SKILL_TYPES: ['grip', 'core', 'dynamic', 'balance'],
            GRADES: ['empty', 'v0', 'v1', 'v2', 'v3', 'v4', 'v5', 'v6', 'v7'],
            GRADE_NAMES: ['', 'V0', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7+'],
            SKILL_NAMES: {
                grip: 'ğŸ’ª ê·¸ë¦½ë ¥',
                core: 'ğŸ‹ï¸ ì½”ì–´',
                dynamic: 'ğŸš€ ë‹¤ì´ë‚˜ë¯¹',
                balance: 'âš–ï¸ ë°¸ëŸ°ìŠ¤'
            },
            BONUS_TYPES: ['bonus_hold', 'tile_delete', 'shuffle_card', 'crux'],
            STORAGE_KEY: 'boulderMasterBest',
            V7_VALUE: 8,
            MAX_MERGEABLE_VALUE: 7,
            BONUS_INTERVAL: 10
        };

        // GAME STATE
        let game = null;
        let currentBonus = null;
        let isDeleteMode = false;
        let isBonusCardOpen = false;
        let bonusCardEnabled = true;

        // UTILITY FUNCTIONS
        function createEmptyBoard() {
            return Array(GAME_CONFIG.BOARD_SIZE).fill()
                .map(() => Array(GAME_CONFIG.BOARD_SIZE).fill(0));
        }

        function deepCopyBoard(board) {
            return board.map(row => [...row]);
        }

        function getRandomTile() {            
			return Math.random() < 0.9 ? 1 : 2; // 90% V0, 10% V1
        }

        function getEmptyCells(board) {
            const emptyCells = [];
            for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            return emptyCells;
        }

        function isSkillTile(value) {
            return typeof value === 'string' && value.startsWith('skill-');
        }

        function getSkillType(skillTile) {
            return skillTile.split('-')[1];
        }

        function isCruxTile(value) {
            return typeof value === 'object' && value && value.type === 'crux';
        }

        function isDeletableTile(value) {
            // ë¹ˆ íƒ€ì¼, í¬ëŸ­ìŠ¤ íƒ€ì¼, ìŠ¤í‚¬ íƒ€ì¼ì€ ì‚­ì œ ë¶ˆê°€
            return value !== 0 && !isCruxTile(value) && !isSkillTile(value);
        }

        function processCruxTiles(board) {
            for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    if (isCruxTile(board[i][j])) {
                        board[i][j].remaining--;
                        if (board[i][j].remaining <= 0) {
                            board[i][j] = 0; // í¬ëŸ­ìŠ¤ ì œê±°
                        }
                    }
                }
            }
        }

        // DOM MANIPULATION
        function updateScore(score) {
            document.getElementById('score').textContent = score;
        }
        
        function updateBestScore(bestScore) {
            document.getElementById('best-score').textContent = bestScore;
            document.getElementById('opening-best-score').textContent = bestScore;
        }

        function updateMoveCount(count) {
            document.getElementById('move-count').textContent = count;
        }
        
        function updateSkillsDisplay(skills) {
            Object.keys(skills).forEach(skill => {
                const element = document.getElementById(`skill-${skill}`);
                element.classList.toggle('acquired', skills[skill]);
            });
        }
        
        function showAchievement(message) {
            const achievementDisplay = document.getElementById('achievement-display');
            achievementDisplay.textContent = message;
            achievementDisplay.classList.add('show');
            setTimeout(() => {
                achievementDisplay.classList.remove('show');
            }, 3000);
        }
        
        function showGameOver(won, score) {
            const gameOverDiv = document.getElementById('game-over');
            const title = document.getElementById('game-over-title');
            const message = document.getElementById('game-over-message');
            const finalScore = document.getElementById('final-score');
            
            if (won) {
                title.textContent = 'ğŸ† í´ë¼ì´ë° ë§ˆìŠ¤í„°! ğŸ†';
                message.textContent = '4ê°€ì§€ ìŠ¤í‚¬ì„ ëª¨ë‘ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ë‹¹ì‹ ì€ ì§„ì •í•œ ë³¼ë”ë§ ê³ ìˆ˜ì…ë‹ˆë‹¤!';
            } else {
                title.textContent = 'ì„¸ì…˜ ì¢…ë£Œ';
                message.textContent = 'ë” ì´ìƒ í™€ë“œë¥¼ ì¡ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
            }
            
            finalScore.textContent = score;
            gameOverDiv.style.display = 'flex';
        }
        
        function hideGameOver() {
            document.getElementById('game-over').style.display = 'none';
        }

        function showOpeningScreen() {
            document.getElementById('opening-screen').style.display = 'flex';
            document.getElementById('guide-screen').style.display = 'none';
            document.getElementById('game-container').classList.remove('show');
        }

        function hideOpeningScreen() {
            document.getElementById('opening-screen').style.display = 'none';
            setTimeout(() => {
                document.getElementById('game-container').classList.add('show');
            }, 300);
        }

        function showGuideScreen() {
            document.getElementById('guide-screen').style.display = 'flex';
            document.getElementById('opening-screen').style.display = 'none';
            document.getElementById('game-container').classList.remove('show');
        }

        function hideGuideScreen() {
            document.getElementById('guide-screen').style.display = 'none';
        }

        function enableTileDeleteMode() {
            document.getElementById('tile-delete-mode').style.display = 'flex';
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, index) => {
                const row = Math.floor(index / GAME_CONFIG.BOARD_SIZE);
                const col = index % GAME_CONFIG.BOARD_SIZE;
                const tileValue = game.board[row][col];
                
                if (isDeletableTile(tileValue)) {
                    tile.classList.add('clickable');
                }
            });
            isBonusCardOpen = true;
        }

        function disableTileDeleteMode() {
            document.getElementById('tile-delete-mode').style.display = 'none';
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.remove('clickable');
            });
            isBonusCardOpen = false;
        }

        function showBonusCardReceive() {
            const element = document.getElementById('bonus-card-receive');
            if (element) {
                element.style.display = 'flex';
                isBonusCardOpen = true;
            }
        }

        function hideBonusCardReceive() {
            const element = document.getElementById('bonus-card-receive');
            if (element) {
                element.style.display = 'none';
                isBonusCardOpen = false;
            }
        }

        function showBonusCardConfirm(bonusType) {
            const bonusDisplay = document.getElementById('bonus-card-confirm');
            const icon = document.getElementById('bonus-card-icon');
            const title = document.getElementById('bonus-card-title');
            const description = document.getElementById('bonus-card-description');
            const question = document.getElementById('bonus-card-question');
            const actions = document.getElementById('bonus-card-actions');

            const bonusInfo = getBonusInfo(bonusType);
            icon.textContent = bonusInfo.icon;
            title.textContent = bonusInfo.title;
            description.textContent = bonusInfo.description;
            
            if (bonusType === 'crux') {
                question.textContent = 'í¬ëŸ­ìŠ¤ê°€ ìë™ìœ¼ë¡œ ë°œë™ë©ë‹ˆë‹¤!';
                actions.style.display = 'none';
                setTimeout(() => {
                    addCrux();
                    hideBonusCardConfirm();
                    currentBonus = null;
                }, 2000);
            } else {
                question.textContent = 'ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
                actions.style.display = 'flex';
            }

            bonusDisplay.style.display = 'flex';
            isBonusCardOpen = true;
        }

        function hideBonusCardConfirm() {
            const bonusDisplay = document.getElementById('bonus-card-confirm');
            const actions = document.getElementById('bonus-card-actions');
            
            if (bonusDisplay) {
                bonusDisplay.style.display = 'none';
            }
            if (actions) {
                actions.style.display = 'flex';
            }
            isBonusCardOpen = false;
        }

        function getBonusInfo(bonusType) {
            const bonusInfos = {
                bonus_hold: {
                    icon: 'ğŸ§—â€â™‚ï¸',
                    title: 'ë³´ë„ˆìŠ¤ í™€ë“œ!',
                    description: 'V5 í™€ë“œê°€ ë¬´ì‘ìœ„ ìœ„ì¹˜ì— ìƒì„±ë©ë‹ˆë‹¤!'
                },
                tile_delete: {
                    icon: 'ğŸ—‘ï¸',
                    title: 'í™€ë“œ(íƒ€ì¼) ì‚­ì œ ì¹´ë“œ!',
                    description: 'ë§ˆìŒì— ì•ˆ ë“œëŠ” í™€ë“œë¥¼ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!'
                },
                shuffle_card: {
                    icon: 'ğŸ²',
                    title: 'ë¬´ì‘ìœ„ ì¬ë°°ì¹˜ ì¹´ë“œ!',
                    description: 'ë¬´ì‘ìœ„ë¡œ ê²Œì„ íƒ€ì¼ì„ ì„ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ë‚˜ì¤‘ì— ì‚¬ìš© ê°€ëŠ¥)'
                },
                crux: {
                    icon: 'ğŸª¨',
                    title: 'í¬ëŸ­ìŠ¤!',
                    description: '3í„´ ë™ì•ˆ ì›€ì§ì´ì§€ ì•ŠëŠ” ë°”ìœ„ê°€ ìƒì„±ë©ë‹ˆë‹¤!'
                }
            };
            return bonusInfos[bonusType] || bonusInfos.bonus_hold;
        }

        function showShuffleButton() {
            document.getElementById('shuffle-btn').style.display = 'inline-block';
        }

        function hideShuffleButton() {
            document.getElementById('shuffle-btn').style.display = 'none';
        }

        // RENDER FUNCTIONS
        function renderBoard(board, animateNewTiles = false) {
            const boardElement = document.getElementById('game-board');
            boardElement.innerHTML = '';
            
            for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    const tile = createTileElement(board[i][j], animateNewTiles);
                    boardElement.appendChild(tile);
                }
            }
            setupTileClickHandlers();
        }
        
        function createTileElement(value, isNewTile = false) {
            const tile = document.createElement('div');
            
            if (value === 0) {
                tile.className = 'tile empty';
            } else if (isCruxTile(value)) {
                renderCruxTile(tile, value, isNewTile);
            } else if (isSkillTile(value)) {
                renderSkillTile(tile, value, isNewTile);
            } else {
                renderGradeTile(tile, value, isNewTile);
            }
            
            return tile;
        }

        function renderCruxTile(tile, cruxTile, isNewTile = false) {
            tile.className = 'tile crux';
            if (isNewTile) {
                tile.classList.add('new-tile');
            }
            
            const icon = document.createElement('div');
            icon.className = 'crux-icon';
            icon.textContent = 'ğŸª¨';
            
            const counter = document.createElement('div');
            counter.className = 'crux-counter';
            counter.textContent = `-${cruxTile.remaining}í„´`;
            
            tile.appendChild(icon);
            tile.appendChild(counter);
        }
        
        function renderSkillTile(tile, skillTile, isNewTile = false) {
            const skillType = getSkillType(skillTile);
            tile.className = `tile ${skillTile}`;
            if (isNewTile) {
                tile.classList.add('new-tile');
            }
            
            const gradeDiv = document.createElement('div');
            gradeDiv.className = 'grade-text';
            gradeDiv.textContent = 'V7+';
            
            const skillDiv = document.createElement('div');
            skillDiv.className = 'skill-text';
            skillDiv.textContent = getSkillDisplayText(skillType);
            
            tile.appendChild(gradeDiv);
            tile.appendChild(skillDiv);
        }
        
        function renderGradeTile(tile, value, isNewTile = false) {
            tile.className = `tile ${GAME_CONFIG.GRADES[value]}`;
            if (isNewTile) {
                tile.classList.add('new-tile');
            }
            tile.textContent = GAME_CONFIG.GRADE_NAMES[value];
        }
        
        function getSkillDisplayText(skillType) {
            const skillTexts = {
                grip: 'ê·¸ë¦½ë ¥',
                core: 'ì½”ì–´',
                dynamic: 'ë‹¤ì´ë‚˜ë¯¹',
                balance: 'ë°¸ëŸ°ìŠ¤'
            };
            return skillTexts[skillType] || 'ìŠ¤í‚¬';
        }

        function setupTileClickHandlers() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, index) => {
                const row = Math.floor(index / GAME_CONFIG.BOARD_SIZE);
                const col = index % GAME_CONFIG.BOARD_SIZE;
                
                tile.onclick = () => {
                    if (isDeleteMode) {
                        deleteTile(row, col);
                    }
                };
            });
        }

        // GAME LOGIC
        function canMerge(a, b) {
            if (a === 0 || b === 0) return false;
            if (isSkillTile(a) || isSkillTile(b)) return false;
            if (isCruxTile(a) || isCruxTile(b)) return false;
            return a === b && a >= 1 && a <= GAME_CONFIG.MAX_MERGEABLE_VALUE;
        }
        
        function processLine(line) {
            let newLine = [];
            let cruxPositions = [];
            
            for (let i = 0; i < line.length; i++) {
                if (isCruxTile(line[i])) {
                    cruxPositions.push({pos: i, tile: line[i]});
                }
            }
            
            let movableTiles = line.filter(cell => !isCruxTile(cell) && cell !== 0);
            let moved = false;
            let merges = 0;
            
            for (let i = 0; i < movableTiles.length - 1; i++) {
                if (canMerge(movableTiles[i], movableTiles[i + 1])) {
                    const mergedValue = movableTiles[i] + 1;
                    movableTiles[i] = mergedValue;
                    movableTiles.splice(i + 1, 1);
                    merges++;
                    moved = true;
                }
            }
            
            newLine = new Array(GAME_CONFIG.BOARD_SIZE).fill(0);
            
            cruxPositions.forEach(crux => {
                newLine[crux.pos] = crux.tile;
            });
            
            let insertIndex = 0;
            for (let tile of movableTiles) {
                while (insertIndex < GAME_CONFIG.BOARD_SIZE && newLine[insertIndex] !== 0) {
                    insertIndex++;
                }
                if (insertIndex < GAME_CONFIG.BOARD_SIZE) {
                    newLine[insertIndex] = tile;
                    insertIndex++;
                }
            }
            
            if (JSON.stringify(line) !== JSON.stringify(newLine)) {
                moved = true;
            }
            
            return { line: newLine, moved, merges };
        }
        
        function moveBoard(board, direction) {
            let moved = false;
            let totalMerges = 0;
            
            if (direction === 'left') {
                for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                    const result = processLine(board[i]);
                    board[i] = result.line;
                    if (result.moved) moved = true;
                    totalMerges += result.merges;
                }
            } else if (direction === 'right') {
                for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                    const result = processLine([...board[i]].reverse());
                    board[i] = result.line.reverse();
                    if (result.moved) moved = true;
                    totalMerges += result.merges;
                }
            } else if (direction === 'up') {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    const column = [board[0][j], board[1][j], board[2][j], board[3][j]];
                    const result = processLine(column);
                    for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                        board[i][j] = result.line[i];
                    }
                    if (result.moved) moved = true;
                    totalMerges += result.merges;
                }
            } else if (direction === 'down') {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    const column = [board[0][j], board[1][j], board[2][j], board[3][j]];
                    const result = processLine([...column].reverse());
                    const newColumn = result.line.reverse();
                    for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                        board[i][j] = newColumn[i];
                    }
                    if (result.moved) moved = true;
                    totalMerges += result.merges;
                }
            }
            
            return { moved, merges: totalMerges };
        }
        
        function hasAvailableMoves(board) {
            for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    if (board[i][j] === 0) return true;
                }
            }
            
            for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                    const current = board[i][j];
                    if (isCruxTile(current)) continue;
                    if (i < 3 && canMerge(current, board[i + 1][j])) return true;
                    if (j < 3 && canMerge(current, board[i][j + 1])) return true;
                }
            }
            
            return false;
        }

        // BONUS FUNCTIONS
        function addBonusHold() {
            const emptyCells = getEmptyCells(game.board);
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                game.board[randomCell.x][randomCell.y] = 6; // V5
                showAchievement('ë³´ë„ˆìŠ¤ V5 í™€ë“œ ìƒì„±!');
                game.renderWithNewTileAnimation([{x: randomCell.x, y: randomCell.y}]);
            }
        }

        function startTileDeleteMode() {
            hideBonusCardConfirm();
            enableTileDeleteMode();
            isDeleteMode = true;
            currentBonus = null;
        }

        function deleteTile(row, col) {
            if (isDeleteMode && isDeletableTile(game.board[row][col])) {
                game.board[row][col] = 0;
                showAchievement('íƒ€ì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
                game.render();
                cancelTileDelete();
            }
        }

        function cancelTileDelete() {
            isDeleteMode = false;
            disableTileDeleteMode();
        }

        function giveShuffleCard() {
            game.hasShuffle = true;
            showShuffleButton();
            showAchievement('ë¬´ì‘ìœ„ ì¬ë°°ì¹˜ ì¹´ë“œ íšë“!');
        }

        function addCrux() {
            const emptyCells = getEmptyCells(game.board);
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                game.board[randomCell.x][randomCell.y] = {
                    type: 'crux',
                    remaining: 3
                };
                showAchievement('í¬ëŸ­ìŠ¤ ìƒì„±! 3í„´ í›„ ì‚¬ë¼ì§‘ë‹ˆë‹¤');
                game.renderWithNewTileAnimation([{x: randomCell.x, y: randomCell.y}]);
            }
        }

        // GAME CLASS
        class BoulderMasterGame {
            constructor() {
                this.board = createEmptyBoard();
                this.gameOver = false;
                this.moveCount = 0;
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem(GAME_CONFIG.STORAGE_KEY) || '0');
                this.hasShuffle = false;
                
                this.skills = {
                    grip: false,
                    core: false,
                    dynamic: false,
                    balance: false
                };
                this.skillCount = 0;
                
                this.initialized = false;
            }
            
            init() {
                if (!this.initialized) {
                    this.addRandomTile();
                    this.addRandomTile();
                    this.initialized = true;
                }
                this.updateDisplay();
                this.render();
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆê°€ ì¤‘ë³µìœ¼ë¡œ ë“±ë¡ë˜ì§€ ì•Šë„ë¡ ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±°
                this.removeEventListeners();

                // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
                this.keydownHandler = (e) => {
                    if (this.gameOver || isBonusCardOpen || isDeleteMode) return;
                    
                    const keyActions = {
                        'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                        'ArrowDown': 'down', 's': 'down', 'S': 'down',
                        'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                        'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                    };
                    
                    const direction = keyActions[e.key];
                    if (direction) {
                        e.preventDefault();
                        this.handleMove(direction);
                    }
                };
                
                document.addEventListener('keydown', this.keydownHandler);

                // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼ ì§€ì›)
                this.touchStartX = 0;
                this.touchStartY = 0;

                const gameContainer = document.getElementById('game-container');
                
                this.touchStartHandler = (e) => {
                    if (this.gameOver || isBonusCardOpen || isDeleteMode) return;
                    
                    // If the touch starts on a button, do not initiate swipe tracking.
                    if (e.target.closest('.btn')) {
                        this.touchStartX = null; // Use null to indicate no swipe should be processed.
                        this.touchStartY = null;
                        return;
                    }

                    const touch = e.touches[0] || e.changedTouches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                };

                this.touchMoveHandler = (e) => {
                    if (this.gameOver || isBonusCardOpen || isDeleteMode) return;
                    e.preventDefault(); // ìŠ¤í¬ë¡¤ ë°©ì§€
                };

                this.touchEndHandler = (e) => {
                    if (this.gameOver || isBonusCardOpen || isDeleteMode) return;
                    
                    // If swipe tracking was not initiated, do nothing.
                    if (this.touchStartX === null || this.touchStartY === null) {
                        return;
                    }

                    e.preventDefault();
                    
                    const touch = e.changedTouches[0];
                    const touchEndX = touch.clientX;
                    const touchEndY = touch.clientY;
                    
                    this.handleSwipe(this.touchStartX, this.touchStartY, touchEndX, touchEndY);
                };

                gameContainer.addEventListener('touchstart', this.touchStartHandler, { passive: false });
                gameContainer.addEventListener('touchmove', this.touchMoveHandler, { passive: false });
                gameContainer.addEventListener('touchend', this.touchEndHandler, { passive: false });

                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (ë°ìŠ¤í¬í†±ì—ì„œ ë“œë˜ê·¸ ì§€ì›)
                this.mouseStartX = 0;
                this.mouseStartY = 0;
                this.isMouseDown = false;

                const gameBoard = document.getElementById('game-board');

                this.mouseDownHandler = (e) => {
                    if (this.gameOver || isBonusCardOpen || isDeleteMode) return;
                    e.preventDefault();
                    this.isMouseDown = true;
                    this.mouseStartX = e.clientX;
                    this.mouseStartY = e.clientY;
                };

                this.mouseUpHandler = (e) => {
                    if (this.gameOver || isBonusCardOpen || !this.isMouseDown || isDeleteMode) return;
                    e.preventDefault();
                    this.isMouseDown = false;
                    const mouseEndX = e.clientX;
                    const mouseEndY = e.clientY;
                    this.handleSwipe(this.mouseStartX, this.mouseStartY, mouseEndX, mouseEndY);
                };

                this.mouseLeaveHandler = () => {
                    this.isMouseDown = false;
                };

                gameBoard.addEventListener('mousedown', this.mouseDownHandler);
                gameBoard.addEventListener('mouseup', this.mouseUpHandler);
                gameBoard.addEventListener('mouseleave', this.mouseLeaveHandler);
            }

            removeEventListeners() {
                if (this.keydownHandler) {
                    document.removeEventListener('keydown', this.keydownHandler);
                }
                
                const gameContainer = document.getElementById('game-container');
                const gameBoard = document.getElementById('game-board');
                
                if (this.touchStartHandler) {
                    gameContainer.removeEventListener('touchstart', this.touchStartHandler);
                }
                if (this.touchMoveHandler) {
                    gameContainer.removeEventListener('touchmove', this.touchMoveHandler);
                }
                if (this.touchEndHandler) {
                    gameContainer.removeEventListener('touchend', this.touchEndHandler);
                }
                if (this.mouseDownHandler) {
                    gameBoard.removeEventListener('mousedown', this.mouseDownHandler);
                }
                if (this.mouseUpHandler) {
                    gameBoard.removeEventListener('mouseup', this.mouseUpHandler);
                }
                if (this.mouseLeaveHandler) {
                    gameBoard.removeEventListener('mouseleave', this.mouseLeaveHandler);
                }
            }

            handleSwipe(startX, startY, endX, endY) {
                const minSwipeDistance = 50; // ìµœì†Œ ìŠ¤ì™€ì´í”„ ê±°ë¦¬ë¥¼ ëŠ˜ë¦¼
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                    return; // ë„ˆë¬´ ì§§ì€ ìŠ¤ì™€ì´í”„ëŠ” ë¬´ì‹œ
                }
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // ìˆ˜í‰ ìŠ¤ì™€ì´í”„
                    if (deltaX > 0) {
                        this.handleMove('right');
                    } else {
                        this.handleMove('left');
                    }
                } else {
                    // ìˆ˜ì§ ìŠ¤ì™€ì´í”„
                    if (deltaY > 0) {
                        this.handleMove('down');
                    } else {
                        this.handleMove('up');
                    }
                }
            }

            handleMove(direction) {
                this.removeNewTileMarkers();
                
                const boardBefore = deepCopyBoard(this.board);
                const result = moveBoard(this.board, direction);
                
                if (result.moved) {
                    this.moveCount++;
                    
                    processCruxTiles(this.board);
                    
                    this.convertV7ToSkill();
                    this.calculateScore(result);
                    this.processSkillAcquisition();
                    
                    const emptyCellsBefore = getEmptyCells(this.board);
                    this.addRandomTile();
                    const emptyCellsAfter = getEmptyCells(this.board);
                    
                    const newTilePositions = this.findNewTilePositions(emptyCellsBefore, emptyCellsAfter);
                    
                    this.updateDisplay();
                    this.renderWithNewTileAnimation(newTilePositions);
                    
                    if (bonusCardEnabled && this.moveCount % GAME_CONFIG.BONUS_INTERVAL === 0) {
                        setTimeout(() => {
                            this.showRandomBonus();
                        }, 500);
                    }
                    
                    this.checkGameState();
                }
            }

            removeNewTileMarkers() {
                const newTiles = document.querySelectorAll('.tile.new-tile');
                newTiles.forEach(tile => {
                    tile.classList.remove('new-tile');
                });
            }

            findNewTilePositions(emptyCellsBefore, emptyCellsAfter) {
                const newPositions = [];
                
                for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                        const wasEmpty = emptyCellsBefore.some(cell => cell.x === i && cell.y === j);
                        const isEmptyNow = emptyCellsAfter.some(cell => cell.x === i && cell.y === j);
                        
                        if (wasEmpty && !isEmptyNow) {
                            newPositions.push({x: i, y: j});
                        }
                    }
                }
                
                return newPositions;
            }

            renderWithNewTileAnimation(newTilePositions) {
                const boardElement = document.getElementById('game-board');
                boardElement.innerHTML = '';
                
                for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                        const isNewTile = newTilePositions.some(pos => pos.x === i && pos.y === j);
                        const tile = createTileElement(this.board[i][j], isNewTile);
                        boardElement.appendChild(tile);
                    }
                }
                setupTileClickHandlers();
            }

            showRandomBonus() {
                const bonusTypes = GAME_CONFIG.BONUS_TYPES;
                const randomIndex = Math.floor(Math.random() * bonusTypes.length);
                currentBonus = bonusTypes[randomIndex];
                
                showBonusCardReceive();
            }

            shuffleTiles() {
                if (this.hasShuffle) {
                    const tiles = [];
                    const positions = [];
                    
                    for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                        for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                            if (this.board[i][j] !== 0) {
                                tiles.push(this.board[i][j]);
                                positions.push({x: i, y: j});
                            }
                        }
                    }
                    
                    for (let i = tiles.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                    }
                    
                    for (let pos of positions) {
                        this.board[pos.x][pos.y] = 0;
                    }
                    
                    for (let i = 0; i < tiles.length; i++) {
                        const pos = positions[i];
                        this.board[pos.x][pos.y] = tiles[i];
                    }
                    
                    this.hasShuffle = false;
                    hideShuffleButton();
                    showAchievement('íƒ€ì¼ì´ ë¬´ì‘ìœ„ë¡œ ì¬ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    
                    this.render();
                }
            }
            
            calculateScore(result) {
                if (result.merges > 1) {
                    const comboBonus = result.merges * 100;
                    showAchievement(`${result.merges}ì—°ì† ì™„ë“±! +${comboBonus}`);
                    this.addScore(comboBonus);
                }
            }

            addScore(points) {
                this.score += points;
                this.updateBestScore();
                updateScore(this.score);
            }

            updateBestScore() {
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem(GAME_CONFIG.STORAGE_KEY, this.bestScore.toString());
                    updateBestScore(this.bestScore);
                }
            }
            
            processSkillAcquisition() {
                for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                        const cell = this.board[i][j];
                        if (isSkillTile(cell)) {
                            const skillType = getSkillType(cell);
                            if (this.acquireSkill(skillType)) {
                                this.addScore(500);
                            }
                        }
                    }
                }
            }

            acquireSkill(skillType) {
                if (!this.skills[skillType]) {
                    this.skills[skillType] = true;
                    showAchievement(`${GAME_CONFIG.SKILL_NAMES[skillType]} ìŠ¤í‚¬ íšë“!`);
                    updateSkillsDisplay(this.skills);
                    return true;
                }
                return false;
            }

            hasAllSkills() {
                return Object.values(this.skills).every(skill => skill);
            }

            convertV7ToSkill() {
                for (let i = 0; i < GAME_CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < GAME_CONFIG.BOARD_SIZE; j++) {
                        if (this.board[i][j] === GAME_CONFIG.V7_VALUE && this.skillCount < 4) {
                            const skillTile = this.generateSkillTile();
                            if (typeof skillTile === 'string') {
                                this.board[i][j] = skillTile;
                                this.skillCount++;
                            }
                        }
                    }
                }
            }

            generateSkillTile() {
                if (this.skillCount < 4) {
                    return `skill-${GAME_CONFIG.SKILL_TYPES[this.skillCount]}`;
                }
                return GAME_CONFIG.V7_VALUE;
            }
            
            addRandomTile() {
                const emptyCells = getEmptyCells(this.board);
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.board[randomCell.x][randomCell.y] = getRandomTile();
                }
            }
            
            checkGameState() {
                if (this.hasAllSkills()) {
                    setTimeout(() => this.endGame(true), 500);
                    return;
                }
                
                if (!hasAvailableMoves(this.board)) {
                    this.gameOver = true;
                    setTimeout(() => this.endGame(false), 300);
                }
            }
            
            endGame(won) {
                this.gameOver = true;
                showGameOver(won, this.score);
            }

            newGame() {
                this.board = createEmptyBoard();
                this.gameOver = false;
                this.moveCount = 0;
                this.score = 0;
                this.hasShuffle = false;
                
                this.skills = {
                    grip: false,
                    core: false,
                    dynamic: false,
                    balance: false
                };
                this.skillCount = 0;
                
                isDeleteMode = false;
                isBonusCardOpen = false;
                currentBonus = null;
                
                hideGameOver();
                hideShuffleButton();
                disableTileDeleteMode();
                hideBonusCardReceive();
                hideBonusCardConfirm();
                
                this.addRandomTile();
                this.addRandomTile();
                this.updateDisplay();
                this.render();
            }
            
            updateDisplay() {
                updateScore(this.score);
                updateBestScore(this.bestScore);
                updateMoveCount(this.moveCount);
                updateSkillsDisplay(this.skills);
            }
            
            render() {
                renderBoard(this.board);
            }
        }

        // GLOBAL FUNCTIONS
        function gameStart() {
            bonusCardEnabled = document.getElementById('bonus-card-enabled').checked;
            
            hideOpeningScreen();
            hideGuideScreen();
            if (!game) {
                game = new BoulderMasterGame();
            }
            game.init();
        }

        function gameNew() {
            if (game) {
                game.newGame();
            } else {
                game = new BoulderMasterGame();
                game.init();
            }
        }

        function guideShow() {
            showGuideScreen();
        }

        function mainMenuShow() {
            showOpeningScreen();
        }

        function tilesShuffleFunc() {
            if (game) {
                game.shuffleTiles();
            }
        }

        // BONUS CARD GLOBAL FUNCTIONS
        function bonusCardOpen() {
            hideBonusCardReceive();
            if (currentBonus) {
                showBonusCardConfirm(currentBonus);
            }
        }

        function bonusCardDiscard() {
            hideBonusCardReceive();
            currentBonus = null;
            showAchievement('ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ ë²„ë ¸ìŠµë‹ˆë‹¤.');
        }

        function bonusConfirm() {
            if (!currentBonus) return;

            switch (currentBonus) {
                case 'bonus_hold':
                    addBonusHold();
                    break;
                case 'tile_delete':
                    startTileDeleteMode();
                    break;
                case 'shuffle_card':
                    giveShuffleCard();
                    break;
                case 'crux':
                    break;
            }

            if (currentBonus !== 'tile_delete' && currentBonus !== 'crux') {
                hideBonusCardConfirm();
                currentBonus = null;
            }
        }

        function bonusDecline() {
            hideBonusCardConfirm();
            currentBonus = null;
            showAchievement('ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        }

        function tileDeleteCancel() {
            cancelTileDelete();
        }

        // INITIALIZATION
        window.addEventListener('load', () => {
            const bestScore = parseInt(localStorage.getItem(GAME_CONFIG.STORAGE_KEY) || '0');
            updateBestScore(bestScore);
        });
    </script>
</body>
</html>
