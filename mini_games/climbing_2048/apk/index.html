// Initialize on page load
        window.addEventListener('load', () => {
            const bestScore = parseInt(localStorage.getItem(CONFIG.STORAGE_KEY) || '0');
            UI.updateBestScore(bestScore);
            
            // PWA ÏÑúÎπÑÏä§ ÏõåÏª§ Îì±Î°ù
            PWAManager.init();
        });

        // PWA Manager
        const PWAManager = {
            init() {
                this.registerServiceWorker();
                this.setupInstallPrompt();
                this.addToHomeScreenPrompt();
            },

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('sw.js');
                        console.log('Service Worker Îì±Î°ù ÏÑ±Í≥µ:', registration);
                    } catch (error) {
                        console.log('Service Worker Îì±Î°ù Ïã§Ìå®:', error);
                    }
                }
            },

            setupInstallPrompt() {
                let deferredPrompt;

                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    deferredPrompt = e;
                    this.showInstallButton(deferredPrompt);
                });

                window.addEventListener('appinstalled', () => {
                    console.log('PWAÍ∞Ä ÏÑ§ÏπòÎêòÏóàÏäµÎãàÎã§!');
                    this.hideInstallButton();
                });
            },

            showInstallButton(deferredPrompt) {
                // ÏÑ§Ïπò Î≤ÑÌäºÏùÑ Î©îÏù∏ Î©îÎâ¥Ïóê Ï∂îÍ∞Ä
                const openingButtons = document.querySelector('.opening-buttons');
                if (openingButtons && !document.getElementById('install-btn')) {
                    const installBtn = document.createElement('button');
                    installBtn.id = 'install-btn';
                    installBtn.className = 'btn warning';
                    installBtn.innerHTML = 'üì± Ïï±ÏúºÎ°ú ÏÑ§ÏπòÌïòÍ∏∞';
                    installBtn.onclick = () => this.installApp(deferredPrompt);
                    
                    // Í∞ÄÏù¥Îìú Î≤ÑÌäº ÏïûÏóê Ï∂îÍ∞Ä
                    const guideBtn = openingButtons.querySelector('button:last-child');
                    openingButtons.insertBefore(installBtn, guideBtn);
                }
            },

            hideInstallButton() {
                const installBtn = document.getElementById('install-btn');
                if (installBtn) {
                    installBtn.remove();
                }
            },

            async installApp(deferredPrompt) {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('ÏÑ§Ïπò Í≤∞Í≥º:', outcome);
                    deferredPrompt = null;
                    this.hideInstallButton();
                }
            },

            addToHomeScreenPrompt() {
                // iOS SafariÏö© ÏÑ§Ïπò ÏïàÎÇ¥
                if (this.isIOS() && !this.isInStandaloneMode()) {
                    setTimeout(() => {
                        if (!localStorage.getItem('ios-install-prompt-shown')) {
                            UI.showAchievement('SafariÏóêÏÑú "Ìôà ÌôîÎ©¥Ïóê Ï∂îÍ∞Ä"Î°ú Ïï±Ï≤òÎüº ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî!');
                            localStorage.setItem('ios-install-prompt-shown', 'true');
                        }
                    }, 3000);
                }
            },

            isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent);
            },

            isInStandaloneMode() {
                return window.matchMedia('(display-mode: standalone)').matches ||
                       window.navigator.standalone === true;
            }
        };
    </script>
    
    <!-- PWA Îß§ÎãàÌéòÏä§Ìä∏ ÌååÏùºÏùÑ ÏúÑÌïú Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script>
        // Îß§ÎãàÌéòÏä§Ìä∏ ÎèôÏ†Å ÏÉùÏÑ± (Ïã§<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î≥ºÎçîÎßÅ 2048 - ÌÅ¥ÎùºÏù¥Î∞ç 2048 Í≤åÏûÑ</title>
    <meta name="description" content="ÌÅ¥ÎùºÏù¥Î∞ç ÌÖåÎßàÏùò 2048 ÌçºÏ¶ê Í≤åÏûÑ, Î≥ºÎçîÎßÅ 2048! V0Î∂ÄÌÑ∞ V7+ÍπåÏßÄ ÌÅ¥ÎùºÏù¥Î∞ç Í∑∏Î†àÏù¥ÎìúÎ•º Ìï©ÏπòÍ≥† 4Í∞ÄÏßÄ Ïä§ÌÇ¨ÏùÑ Î™®ÏïÑ Î≥ºÎçîÎßÅ ÎßàÏä§ÌÑ∞Í∞Ä ÎêòÏñ¥Î≥¥ÏÑ∏Ïöî.">
    <meta name="keywords" content="2048, ÌÅ¥ÎùºÏù¥Î∞ç, Î≥ºÎçîÎßÅ, ÌçºÏ¶ê Í≤åÏûÑ, ÏõπÍ≤åÏûÑ, 2048 Í≤åÏûÑ, climbing, bouldering, puzzle game">
    
    <meta property="og:title" content="Î≥ºÎçîÎßÅ 2048 - ÌÅ¥ÎùºÏù¥Î∞ç 2048 Í≤åÏûÑ">
    <meta property="og:description" content="V0Î∂ÄÌÑ∞ V7+ÍπåÏßÄ ÌÅ¥ÎùºÏù¥Î∞ç Í∑∏Î†àÏù¥ÎìúÎ•º Ìï©Ï≥ê Î≥ºÎçîÎßÅ ÎßàÏä§ÌÑ∞Ïóê ÎèÑÏ†ÑÌïòÏÑ∏Ïöî!">
    <meta property="og:type" content="website">
    
    <!-- PWA Í¥ÄÎ†® Î©îÌÉÄ ÌÉúÍ∑∏ -->
    <meta name="theme-color" content="#007bff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Î≥ºÎçîÎßÅ 2048">
    
    <!-- PWA Îß§ÎãàÌéòÏä§Ìä∏ -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- ÌååÎπÑÏΩò Î∞è ÏïÑÏù¥ÏΩò -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icon-192.png">
    <link rel="apple-touch-icon" href="/icon-192.png">
    
    <!-- PWA Í¥ÄÎ†® Î©îÌÉÄ ÌÉúÍ∑∏ -->
    <meta name="theme-color" content="#007bff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Î≥ºÎçîÎßÅ 2048">
    
    <!-- PWA Îß§ÎãàÌéòÏä§Ìä∏ -->
    <link rel="manifest" href="manifest.json">
    
    <!-- ÌååÎπÑÏΩò Î∞è ÏïÑÏù¥ÏΩò -->
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üßó‚Äç‚ôÇÔ∏è</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üßó‚Äç‚ôÇÔ∏è</text></svg>">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --background: #f0f2f5;
            --card-background: #ffffff;
            --border-color: #e0e0e0;
            --text-primary: #333;
            --text-secondary: #6c757d;
            --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 8px 25px rgba(0, 0, 0, 0.15);
            --shadow-heavy: 0 15px 40px rgba(0, 0, 0, 0.1);
            --border-radius: 15px;
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: var(--background);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        /* Common Components */
        .btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-light);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 80px;
            touch-action: manipulation;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-medium);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
        }

        .btn.success {
            background: linear-gradient(135deg, var(--success-color), #2ecc71);
        }

        .btn.danger {
            background: linear-gradient(135deg, var(--danger-color), #c0392b);
        }

        .btn.warning {
            background: linear-gradient(135deg, var(--warning-color), #e67e22);
        }

        /* Opening Screen */
        .opening-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e6f7ff 0%, #ffffff 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 1s ease-in-out;
        }

        .opening-screen.hidden {
            display: none;
        }

        .opening-container {
            background: var(--card-background);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: var(--shadow-heavy);
            border: 1px solid var(--border-color);
            max-width: 400px;
            width: 90%;
            animation: slideUp 0.8s ease-out 0.2s both;
        }

        .opening-title {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .climbing-icon {
            font-size: 3em;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border-radius: var(--border-radius);
            padding: 15px;
            color: white;
            box-shadow: 0 10px 25px rgba(254, 202, 87, 0.3);
        }

        .title-text {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #4a4a4a, #212121);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.1em;
            margin-bottom: 30px;
            color: var(--text-secondary);
        }

        .best-score-display {
            background: #f7f9fa;
            border-radius: var(--border-radius);
            padding: 15px;
            margin: 20px 0;
            border: 1px solid #e0e6ed;
        }

        .best-score-label {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .best-score-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--primary-color);
        }

        .opening-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            cursor: pointer;
            user-select: none;
            color: var(--text-primary);
            font-size: 1em;
            font-weight: 500;
        }

        .checkbox-container input {
            display: none;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            background: #e0e6ed;
            border: 2px solid #ced4da;
            border-radius: 4px;
            margin-right: 10px;
            position: relative;
            transition: var(--transition);
        }

        .checkbox-container input:checked + .checkmark {
            background: var(--primary-color);
            border-color: var(--primary-hover);
        }

        .checkbox-container input:checked + .checkmark::after {
            content: '‚úì';
            position: absolute;
            left: 3px;
            top: -2px;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        /* Guide Screen */
        .guide-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e6f7ff 0%, #ffffff 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            overflow-y: auto;
        }

        .guide-container {
            background: var(--card-background);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: var(--shadow-heavy);
            border: 1px solid var(--border-color);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .guide-title {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .guide-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .guide-content {
            text-align: left;
        }

        .guide-section {
            background: #f8f9fa;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .guide-section h3 {
            color: var(--primary-color);
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
        }

        .guide-section p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #495057;
            font-size: 0.95em;
        }

        /* Game Container */
        .game-container {
            text-align: center;
            background: var(--card-background);
            border-radius: 20px;
            padding: 20px;
            box-shadow: var(--shadow-heavy);
            border: 1px solid var(--border-color);
            position: relative;
            max-width: 400px;
            width: 100%;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.5s ease;
        }

        .game-container.show {
            opacity: 1;
            transform: translateY(0);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 15px;
            color: #343a40;
            letter-spacing: 1px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 0.8em;
            margin-bottom: 3px;
            color: var(--text-secondary);
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #343a40;
        }

        .skills-container {
            background: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
        }

        .skills-title {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: var(--warning-color);
            font-weight: bold;
        }

        .skills-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .skill-slot {
            background: #e9ecef;
            border: 2px dashed #ced4da;
            border-radius: 10px;
            padding: 10px 5px;
            min-height: 55px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .skill-slot.acquired {
            background: linear-gradient(135deg, var(--success-color), #2ecc71);
            border: 2px solid var(--success-color);
            color: white;
            font-weight: bold;
            animation: skillGlow 2s infinite alternate;
        }

        /* Game Board */
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            background: #e9ecef;
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            border: 1px solid #dee2e6;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            touch-action: none;
            user-select: none;
        }

        .tile {
            aspect-ratio: 1 / 1;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
            border: none;
            position: relative;
            cursor: pointer;
        }

        .tile.empty {
            background: #d6dbe0;
            border: 2px dashed #b8c0c8;
        }

        .tile.new-tile {
            animation: tileAppear 0.4s ease-out;
        }

        .tile.new-tile::before {
            content: 'N';
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 3px;
            padding: 1px 3px;
            font-size: 0.6em;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
        }

        .tile.clickable {
            cursor: pointer;
            border: 3px solid #feca57;
            animation: clickablePulse 1s infinite;
        }

        .tile.crux {
            background: linear-gradient(135deg, var(--secondary-color), #343a40) !important;
            border: 3px solid #495057 !important;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .tile.crux .crux-icon {
            font-size: 1.8em;
            margin-bottom: 2px;
        }

        .tile.crux .crux-counter {
            font-size: 0.7em;
            color: #feca57;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 2px 6px;
            font-weight: bold;
        }

        /* Grade Colors */
        .tile.v0 { 
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            color: white;
        }
        .tile.v1 { 
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }
        .tile.v2 { 
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            box-shadow: 0 4px 15px rgba(241, 196, 15, 0.3);
        }
        .tile.v3 { 
            background: linear-gradient(135deg, #27ae60, #229954);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }
        .tile.v4 { 
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            color: white;
        }
        .tile.v5 { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        .tile.v6 { 
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
            color: white;
        }
        .tile.v7 { 
            background: linear-gradient(135deg, #2c3e50, #34495e);
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.3);
            color: white;
            border: 2px solid #ecf0f1;
        }

        /* Skill Tiles */
        .tile.skill-grip { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #e74c3c);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-core { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #f39c12);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-dynamic { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #27ae60);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-balance { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #3498db);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }

        .controls {
            margin: 25px 0 10px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .shuffle-btn {
            background: #9b59b6;
            font-size: 1.2em;
            padding: 10px 20px;
        }

        .shuffle-btn:hover {
            background: #8e44ad;
        }

        /* Modal Components */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--card-background);
            color: var(--text-primary);
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            max-width: 400px;
        }

        /* Bonus Card */
        .bonus-card-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            z-index: 1500;
            height: 100%;
            pointer-events: none;
        }

        .bonus-card-content {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            max-width: 350px;
            width: 90%;
            animation: cardSlideDown 0.5s ease;
            color: white;
            pointer-events: auto;
        }

        .bonus-card-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .bonus-card-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 1px 1px 5px rgba(0,0,0,0.2);
        }

        .bonus-card-description {
            font-size: 1em;
            margin-bottom: 20px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }

        .bonus-card-question {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }

        .bonus-card-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .bonus-card-actions .btn {
            padding: 10px 20px;
            font-size: 0.9em;
            min-width: 60px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* Achievement Display */
        .achievement-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--success-color), #2ecc71);
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            font-weight: bold;
            opacity: 0;
            transition: var(--transition);
            z-index: 100;
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .achievement-display.show {
            opacity: 1;
            animation: achievementShow 3s ease;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes tileAppear {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes skillGlow {
            0% { box-shadow: 0 0 5px rgba(39, 174, 96, 0.5); }
            100% { box-shadow: 0 0 20px rgba(39, 174, 96, 0.8); }
        }

        @keyframes skillPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(44, 62, 80, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 25px rgba(44, 62, 80, 0.8);
            }
        }

        @keyframes clickablePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes cardSlideDown {
            from { 
                transform: translateY(-50px) scale(0.8);
                opacity: 0;
            }
            to { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes achievementShow {
            0% { 
                transform: translateX(100px) scale(0.8); 
                opacity: 0; 
            }
            20%, 80% { 
                transform: translateX(0) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translateX(100px) scale(0.8); 
                opacity: 0; 
            }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .guide-container {
                padding: 25px;
                margin: 10px;
            }
            
            .guide-section {
                padding: 15px;
            }

            .game-container {
                padding: 15px;
            }

            .game-board {
                gap: 8px;
                padding: 10px;
            }

            .opening-container {
                padding: 30px 25px;
            }

            .title-text {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <!-- Opening Screen -->
    <div class="opening-screen" id="opening-screen">
        <div class="opening-container">
            <div class="opening-title">
                <div class="climbing-icon">üßó‚Äç‚ôÇÔ∏è</div>
                <div class="title-text">Î≥ºÎçîÎßÅ 2048</div>
            </div>
            
            <div class="subtitle">ÌÅ¥ÎùºÏù¥Î∞ç Í∑∏Î†àÏù¥ÎìúÎ•º Ï†ïÎ≥µÌïòÎùº!!!</div>
            
            <div class="best-score-display">
                <div class="best-score-label">ÏµúÍ≥† Ï†êÏàò</div>
                <div class="best-score-value" id="opening-best-score">0</div>
            </div>
            
            <div class="opening-buttons">
                <button class="btn primary" onclick="GameController.startGame()">
                    üéØ ÏÉà Í≤åÏûÑ ÏãúÏûë
                </button>
                
                <label class="checkbox-container">
                    <input type="checkbox" id="bonus-card-enabled" checked>
                    <span class="checkmark"></span>
                    <span class="checkbox-text">Î≥¥ÎÑàÏä§ Ïπ¥Îìú Îì±Ïû•</span>
                </label>
                
                <button class="btn" onclick="UI.showGuide()">
                    üìñ Í∞ÄÏù¥Îìú Î≥¥Í∏∞
                </button>
            </div>
        </div>
    </div>

    <!-- Guide Screen -->
    <div class="guide-screen" id="guide-screen">
        <div class="guide-container">
            <div class="guide-title">
                <div class="climbing-icon">üßó‚Äç‚ôÇÔ∏è</div>
                <div class="title-text">ÌÅ¥ÎùºÏù¥Î∞ç Í∞ÄÏù¥Îìú</div>
            </div>
            
            <div class="guide-buttons">
                <button class="btn primary" onclick="GameController.startGame()">
                    üéØ Í≤åÏûÑ ÏãúÏûëÌïòÍ∏∞
                </button>
                <button class="btn" onclick="UI.showMainMenu()">
                    üè† Î©îÏù∏Î©îÎâ¥ Í∞ÄÍ∏∞
                </button>
            </div>
            
            <div class="guide-content">
                <div class="guide-section">
                    <h3>üéÆ Ï°∞ÏûëÎ≤ï</h3>
                    <p><strong>ÌôîÏÇ¥Ìëú ÌÇ§</strong>, <strong>WASD</strong> ÎòêÎäî <strong>Ïä§ÏôÄÏù¥ÌîÑ</strong>Î°ú ÌôÄÎìúÎ•º ÏõÄÏßÅÏù¥ÏÑ∏Ïöî</p>
                    <p><strong>Í∞ôÏùÄ Í∑∏Î†àÏù¥Îìú</strong>Î•º Ìï©Ï≥êÏÑú <strong>ÏÉÅÏúÑ Í∑∏Î†àÏù¥Îìú</strong>Î°ú ÏóÖÍ∑∏Î†àÏù¥ÎìúÌïòÏÑ∏Ïöî</p>
                    <p><strong>V0</strong> ‚Üí <strong>V1</strong> ‚Üí <strong>V2</strong> ‚Üí <strong>V3</strong> ‚Üí <strong>V4</strong> ‚Üí <strong>V5</strong> ‚Üí <strong>V6</strong> ‚Üí <strong>V7+</strong></p>
                </div>
                
                <div class="guide-section">
                    <h3>üèÜ Î™©Ìëú</h3>
                    <p><strong>V7+</strong>Î•º ÎßåÎì§Î©¥ ÏàúÏÑúÎåÄÎ°ú <strong>Ïä§ÌÇ¨</strong>ÏùÑ ÌöçÎìùÌï©ÎãàÎã§</p>
                    <p><strong>üí™ Í∑∏Î¶ΩÎ†•</strong> ‚Üí <strong>üèãÔ∏è ÏΩîÏñ¥</strong> ‚Üí <strong>üöÄ Îã§Ïù¥ÎÇòÎØπ</strong> ‚Üí <strong>‚öñÔ∏è Î∞∏Îü∞Ïä§</strong></p>
                    <p><strong>4Í∞ÄÏßÄ Ïä§ÌÇ¨</strong>ÏùÑ Î™®Îëê ÏàòÏßëÌïòÎ©¥ <strong>ÌÅ¥ÎùºÏù¥Î∞ç ÎßàÏä§ÌÑ∞</strong>!</p>
                </div>
                
                <div class="guide-section">
                    <h3>üéÅ Î≥¥ÎÑàÏä§ Ïπ¥Îìú (10Î≤à ÏõÄÏßÅÏùº ÎïåÎßàÎã§)</h3>
                    <p><strong>üßó‚Äç‚ôÇÔ∏è Î≥¥ÎÑàÏä§ ÌôÄÎìú:</strong> V5 ÌÉÄÏùºÏù¥ Î¨¥ÏûëÏúÑ ÏúÑÏπòÏóê ÏÉùÏÑ±</p>
                    <p><strong>üóëÔ∏è ÌôÄÎìú(ÌÉÄÏùº) ÏÇ≠Ï†ú:</strong> ÎßàÏùåÏóê Ïïà ÎìúÎäî ÌôÄÎìúÎ•º ÏÇ≠Ï†ú</p>
                    <p><strong>üé≤ Î¨¥ÏûëÏúÑ Ïû¨Î∞∞Ïπò:</strong> Î™®Îì† ÌÉÄÏùºÏùÑ ÏÑûÏñ¥ÏÑú Ïû¨Î∞∞Ïπò</p>
                    <p><strong>ü™® ÌÅ¨Îü≠Ïä§:</strong> 3ÌÑ¥ ÎèôÏïà ÏõÄÏßÅÏù¥ÏßÄ ÏïäÎäî Î∞îÏúÑ ÏÉùÏÑ±</p>
                </div>
                
                <div class="guide-section">
                    <h3>üéØ ÌåÅ</h3>
                    <p>Ïó∞ÏÜçÏúºÎ°ú Ìï©ÏπòÎ©¥ <strong>ÏΩ§Î≥¥ Î≥¥ÎÑàÏä§</strong>Î•º ÌöçÎìùÌï† Ïàò ÏûàÏäµÎãàÎã§</p>
                    <p>Ïä§ÌÇ¨ ÌÉÄÏùºÏùÄ ÌäπÎ≥ÑÌïú <strong>Ïï†ÎãàÎ©îÏù¥ÏÖò Ìö®Í≥º</strong>Î°ú ÌëúÏãúÎê©ÎãàÎã§</p>
                    <p>Î≥¥ÎÑàÏä§ Ïπ¥ÎìúÎäî ÏÑ†ÌÉùÏ†ÅÏúºÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§</p>
                    <p>Ï†ÑÎûµÏ†ÅÏúºÎ°ú ÏõÄÏßÅÏó¨ÏÑú <strong>ÏµúÍ≥† Ï†êÏàò</strong>Ïóê ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="game-container">
        <!-- Bonus Card Displays -->
        <div class="bonus-card-display" id="bonus-card-receive">
            <div class="bonus-card-content">
                <div class="bonus-card-icon">üéÅ</div>
                <div class="bonus-card-title">Î≥¥ÎÑàÏä§ Ïπ¥Îìú ÌöçÎìù!</div>
                <div class="bonus-card-description">10ÌÑ¥ÎßàÎã§ Î∞õÎäî ÌäπÎ≥ÑÌïú Î≥¥ÎÑàÏä§ Ïπ¥ÎìúÏûÖÎãàÎã§!</div>
                <div class="bonus-card-question">Ïπ¥ÎìúÎ•º Ïó¥Ïñ¥Î≥¥ÏãúÍ≤†ÏäµÎãàÍπå?</div>
                <div class="bonus-card-actions">
                    <button class="btn success" onclick="BonusCardManager.openCard()">Ïπ¥Îìú Ïó¥Í∏∞</button>
                    <button class="btn danger" onclick="BonusCardManager.discardCard()">Î≤ÑÎ¶¨Í∏∞</button>
                </div>
            </div>
        </div>

        <div class="bonus-card-display" id="bonus-card-confirm">
            <div class="bonus-card-content">
                <div class="bonus-card-icon" id="bonus-card-icon">üéÅ</div>
                <div class="bonus-card-title" id="bonus-card-title">Î≥¥ÎÑàÏä§ Ïπ¥Îìú!</div>
                <div class="bonus-card-description" id="bonus-card-description">Î≥¥ÎÑàÏä§ Ïπ¥ÎìúÎ•º Î∞õÏïòÏäµÎãàÎã§!</div>
                <div class="bonus-card-question" id="bonus-card-question">ÏÇ¨Ïö©ÌïòÏãúÍ≤†ÏäµÎãàÍπå?</div>
                <div class="bonus-card-actions" id="bonus-card-actions">
                    <button class="btn success" onclick="BonusCardManager.confirmUse()">Ïòà</button>
                    <button class="btn danger" onclick="BonusCardManager.declineUse()">ÏïÑÎãàÏò§</button>
                </div>
            </div>
        </div>

        <div class="bonus-card-display" id="tile-delete-mode" style="display: none;">
            <div class="bonus-card-content" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);">
                <div class="bonus-card-icon" style="color: #d63384;">üóëÔ∏è</div>
                <div class="bonus-card-title" style="color: #d63384;">ÌÉÄÏùº ÏÇ≠Ï†ú</div>
                <div class="bonus-card-description" style="color: #333;">Ïñ¥Îäê ÌÉÄÏùºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?<br>ÏÇ≠Ï†úÌï† ÌÉÄÏùºÏùÑ ÌÅ¥Î¶≠Ìï¥Ï£ºÏÑ∏Ïöî.</div>
                <div class="bonus-card-actions">
                    <button class="btn" onclick="TileDeleteManager.cancel()">Ï∑®ÏÜå</button>
                </div>
            </div>
        </div>

        <h1>üßó‚Äç‚ôÇÔ∏è Boulder Master</h1>
        
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">Ï†êÏàò</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ÏµúÍ≥† Ï†êÏàò</div>
                <div class="stat-value" id="best-score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ÏõÄÏßÅÏûÑ</div>
                <div class="stat-value" id="move-count">0</div>
            </div>
        </div>

        <div class="skills-container">
            <div class="skills-title">üéØ ÌÅ¥ÎùºÏù¥Î∞ç Ïä§ÌÇ¨ ÏàòÏßë</div>
            <div class="skills-grid">
                <div class="skill-slot" id="skill-grip">
                    <div>üí™</div>
                    <div>Í∑∏Î¶ΩÎ†•</div>
                </div>
                <div class="skill-slot" id="skill-core">
                    <div>üèãÔ∏è</div>
                    <div>ÏΩîÏñ¥</div>
                </div>
                <div class="skill-slot" id="skill-dynamic">
                    <div>üöÄ</div>
                    <div>Îã§Ïù¥ÎÇòÎØπ</div>
                </div>
                <div class="skill-slot" id="skill-balance">
                    <div>‚öñÔ∏è</div>
                    <div>Î∞∏Îü∞Ïä§</div>
                </div>
            </div>
        </div>

        <div class="game-board" id="game-board"></div>

        <div class="controls">
            <button class="btn primary" onclick="GameController.newGame()">ÏÉà Í≤åÏûÑ</button>
            <button class="btn" onclick="UI.showMainMenu()">Î©îÏù∏ Î©îÎâ¥</button>
            <button class="btn shuffle-btn" id="shuffle-btn" onclick="ShuffleManager.shuffle()" style="display: none;">üé≤</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal-overlay" id="game-over">
        <div class="modal-content">
            <h2 id="game-over-title">ÏÑ∏ÏÖò Ï¢ÖÎ£å!</h2>
            <p id="game-over-message"></p>
            <p>Ï†êÏàò: <span id="final-score"></span></p>
            <button class="btn primary" onclick="GameController.newGame()">Îã§Ïãú ÎèÑÏ†Ñ</button>
            <button class="btn" onclick="UI.showMainMenu()">Î©îÏù∏ ÌôîÎ©¥</button>
        </div>
    </div>

    <!-- Achievement Display -->
    <div class="achievement-display" id="achievement-display"></div>

    <script>
        // Game Configuration
        const CONFIG = {
            BOARD_SIZE: 4,
            SKILL_TYPES: ['grip', 'core', 'dynamic', 'balance'],
            GRADES: ['empty', 'v0', 'v1', 'v2', 'v3', 'v4', 'v5', 'v6', 'v7'],
            GRADE_NAMES: ['', 'V0', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7+'],
            SKILL_NAMES: {
                grip: 'üí™ Í∑∏Î¶ΩÎ†•',
                core: 'üèãÔ∏è ÏΩîÏñ¥',
                dynamic: 'üöÄ Îã§Ïù¥ÎÇòÎØπ',
                balance: '‚öñÔ∏è Î∞∏Îü∞Ïä§'
            },
            BONUS_TYPES: ['bonus_hold', 'tile_delete', 'shuffle_card', 'crux'],
            STORAGE_KEY: 'boulderMasterBest',
            V7_VALUE: 8,
            MAX_MERGEABLE_VALUE: 7,
            BONUS_INTERVAL: 10
        };

        // Utility Functions
        const Utils = {
            createEmptyBoard() {
                return Array(CONFIG.BOARD_SIZE).fill()
                    .map(() => Array(CONFIG.BOARD_SIZE).fill(0));
            },

            deepCopyBoard(board) {
                return board.map(row => [...row]);
            },

            getRandomTile() {
                return Math.random() < 0.9 ? 1 : 2; // 90% V0, 10% V1
            },

            getEmptyCells(board) {
                const emptyCells = [];
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (board[i][j] === 0) {
                            emptyCells.push({x: i, y: j});
                        }
                    }
                }
                return emptyCells;
            },

            isSkillTile(value) {
                return typeof value === 'string' && value.startsWith('skill-');
            },

            getSkillType(skillTile) {
                return skillTile.split('-')[1];
            },

            isCruxTile(value) {
                return typeof value === 'object' && value && value.type === 'crux';
            },

            isDeletableTile(value) {
                return value !== 0 && !this.isCruxTile(value) && !this.isSkillTile(value);
            },

            processCruxTiles(board) {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (this.isCruxTile(board[i][j])) {
                            board[i][j].remaining--;
                            if (board[i][j].remaining <= 0) {
                                board[i][j] = 0;
                            }
                        }
                    }
                }
            }
        };

        // UI Manager
        const UI = {
            updateScore(score) {
                document.getElementById('score').textContent = score;
            },
            
            updateBestScore(bestScore) {
                document.getElementById('best-score').textContent = bestScore;
                document.getElementById('opening-best-score').textContent = bestScore;
            },

            updateMoveCount(count) {
                document.getElementById('move-count').textContent = count;
            },
            
            updateSkillsDisplay(skills) {
                Object.keys(skills).forEach(skill => {
                    const element = document.getElementById(`skill-${skill}`);
                    element.classList.toggle('acquired', skills[skill]);
                });
            },
            
            showAchievement(message) {
                const achievementDisplay = document.getElementById('achievement-display');
                achievementDisplay.textContent = message;
                achievementDisplay.classList.add('show');
                setTimeout(() => {
                    achievementDisplay.classList.remove('show');
                }, 3000);
            },
            
            showGameOver(won, score) {
                const gameOverDiv = document.getElementById('game-over');
                const title = document.getElementById('game-over-title');
                const message = document.getElementById('game-over-message');
                const finalScore = document.getElementById('final-score');
                
                if (won) {
                    title.textContent = 'üèÜ ÌÅ¥ÎùºÏù¥Î∞ç ÎßàÏä§ÌÑ∞! üèÜ';
                    message.textContent = '4Í∞ÄÏßÄ Ïä§ÌÇ¨ÏùÑ Î™®Îëê ÎßàÏä§ÌÑ∞ÌñàÏäµÎãàÎã§! ÎãπÏã†ÏùÄ ÏßÑÏ†ïÌïú Î≥ºÎçîÎßÅ Í≥†ÏàòÏûÖÎãàÎã§!';
                } else {
                    title.textContent = 'ÏÑ∏ÏÖò Ï¢ÖÎ£å';
                    message.textContent = 'Îçî Ïù¥ÏÉÅ ÌôÄÎìúÎ•º Ïû°ÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Îã§Ïãú ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî!';
                }
                
                finalScore.textContent = score;
                gameOverDiv.style.display = 'flex';
            },
            
            hideGameOver() {
                document.getElementById('game-over').style.display = 'none';
            },

            showMainMenu() {
                document.getElementById('opening-screen').style.display = 'flex';
                document.getElementById('guide-screen').style.display = 'none';
                document.getElementById('game-container').classList.remove('show');
            },

            hideMainMenu() {
                document.getElementById('opening-screen').style.display = 'none';
                setTimeout(() => {
                    document.getElementById('game-container').classList.add('show');
                }, 300);
            },

            showGuide() {
                document.getElementById('guide-screen').style.display = 'flex';
                document.getElementById('opening-screen').style.display = 'none';
                document.getElementById('game-container').classList.remove('show');
            },

            hideGuide() {
                document.getElementById('guide-screen').style.display = 'none';
            }
        };

        // Render Manager
        const RenderManager = {
            renderBoard(board, animateNewTiles = false) {
                const boardElement = document.getElementById('game-board');
                boardElement.innerHTML = '';
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const tile = this.createTileElement(board[i][j], animateNewTiles);
                        boardElement.appendChild(tile);
                    }
                }
                this.setupTileClickHandlers();
            },
            
            createTileElement(value, isNewTile = false) {
                const tile = document.createElement('div');
                
                if (value === 0) {
                    tile.className = 'tile empty';
                } else if (Utils.isCruxTile(value)) {
                    this.renderCruxTile(tile, value, isNewTile);
                } else if (Utils.isSkillTile(value)) {
                    this.renderSkillTile(tile, value, isNewTile);
                } else {
                    this.renderGradeTile(tile, value, isNewTile);
                }
                
                return tile;
            },

            renderCruxTile(tile, cruxTile, isNewTile = false) {
                tile.className = 'tile crux';
                if (isNewTile) {
                    tile.classList.add('new-tile');
                }
                
                const icon = document.createElement('div');
                icon.className = 'crux-icon';
                icon.textContent = 'ü™®';
                
                const counter = document.createElement('div');
                counter.className = 'crux-counter';
                counter.textContent = `-${cruxTile.remaining}ÌÑ¥`;
                
                tile.appendChild(icon);
                tile.appendChild(counter);
            },
            
            renderSkillTile(tile, skillTile, isNewTile = false) {
                const skillType = Utils.getSkillType(skillTile);
                tile.className = `tile ${skillTile}`;
                if (isNewTile) {
                    tile.classList.add('new-tile');
                }
                
                const gradeDiv = document.createElement('div');
                gradeDiv.className = 'grade-text';
                gradeDiv.textContent = 'V7+';
                
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-text';
                skillDiv.textContent = this.getSkillDisplayText(skillType);
                
                tile.appendChild(gradeDiv);
                tile.appendChild(skillDiv);
            },
            
            renderGradeTile(tile, value, isNewTile = false) {
                tile.className = `tile ${CONFIG.GRADES[value]}`;
                if (isNewTile) {
                    tile.classList.add('new-tile');
                }
                tile.textContent = CONFIG.GRADE_NAMES[value];
            },
            
            getSkillDisplayText(skillType) {
                const skillTexts = {
                    grip: 'Í∑∏Î¶ΩÎ†•',
                    core: 'ÏΩîÏñ¥',
                    dynamic: 'Îã§Ïù¥ÎÇòÎØπ',
                    balance: 'Î∞∏Îü∞Ïä§'
                };
                return skillTexts[skillType] || 'Ïä§ÌÇ¨';
            },

            setupTileClickHandlers() {
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / CONFIG.BOARD_SIZE);
                    const col = index % CONFIG.BOARD_SIZE;
                    
                    tile.onclick = () => {
                        if (TileDeleteManager.isDeleteMode) {
                            TileDeleteManager.deleteTile(row, col);
                        }
                    };
                });
            },

            renderWithNewTileAnimation(board, newTilePositions) {
                const boardElement = document.getElementById('game-board');
                boardElement.innerHTML = '';
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const isNewTile = newTilePositions.some(pos => pos.x === i && pos.y === j);
                        const tile = this.createTileElement(board[i][j], isNewTile);
                        boardElement.appendChild(tile);
                    }
                }
                this.setupTileClickHandlers();
            },

            removeNewTileMarkers() {
                const newTiles = document.querySelectorAll('.tile.new-tile');
                newTiles.forEach(tile => {
                    tile.classList.remove('new-tile');
                });
            }
        };

        // Game Logic
        const GameLogic = {
            canMerge(a, b) {
                if (a === 0 || b === 0) return false;
                if (Utils.isSkillTile(a) || Utils.isSkillTile(b)) return false;
                if (Utils.isCruxTile(a) || Utils.isCruxTile(b)) return false;
                return a === b && a >= 1 && a <= CONFIG.MAX_MERGEABLE_VALUE;
            },
            
            processLine(line) {
                let newLine = [];
                let cruxPositions = [];
                
                for (let i = 0; i < line.length; i++) {
                    if (Utils.isCruxTile(line[i])) {
                        cruxPositions.push({pos: i, tile: line[i]});
                    }
                }
                
                let movableTiles = line.filter(cell => !Utils.isCruxTile(cell) && cell !== 0);
                let moved = false;
                let merges = 0;
                
                for (let i = 0; i < movableTiles.length - 1; i++) {
                    if (this.canMerge(movableTiles[i], movableTiles[i + 1])) {
                        const mergedValue = movableTiles[i] + 1;
                        movableTiles[i] = mergedValue;
                        movableTiles.splice(i + 1, 1);
                        merges++;
                        moved = true;
                    }
                }
                
                newLine = new Array(CONFIG.BOARD_SIZE).fill(0);
                
                cruxPositions.forEach(crux => {
                    newLine[crux.pos] = crux.tile;
                });
                
                let insertIndex = 0;
                for (let tile of movableTiles) {
                    while (insertIndex < CONFIG.BOARD_SIZE && newLine[insertIndex] !== 0) {
                        insertIndex++;
                    }
                    if (insertIndex < CONFIG.BOARD_SIZE) {
                        newLine[insertIndex] = tile;
                        insertIndex++;
                    }
                }
                
                if (JSON.stringify(line) !== JSON.stringify(newLine)) {
                    moved = true;
                }
                
                return { line: newLine, moved, merges };
            },
            
            moveBoard(board, direction) {
                let moved = false;
                let totalMerges = 0;
                
                if (direction === 'left') {
                    for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                        const result = this.processLine(board[i]);
                        board[i] = result.line;
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                } else if (direction === 'right') {
                    for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                        const result = this.processLine([...board[i]].reverse());
                        board[i] = result.line.reverse();
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                } else if (direction === 'up') {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const column = [board[0][j], board[1][j], board[2][j], board[3][j]];
                        const result = this.processLine(column);
                        for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                            board[i][j] = result.line[i];
                        }
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                } else if (direction === 'down') {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const column = [board[0][j], board[1][j], board[2][j], board[3][j]];
                        const result = this.processLine([...column].reverse());
                        const newColumn = result.line.reverse();
                        for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                            board[i][j] = newColumn[i];
                        }
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                }
                
                return { moved, merges: totalMerges };
            },
            
            hasAvailableMoves(board) {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (board[i][j] === 0) return true;
                    }
                }
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const current = board[i][j];
                        if (Utils.isCruxTile(current)) continue;
                        if (i < 3 && this.canMerge(current, board[i + 1][j])) return true;
                        if (j < 3 && this.canMerge(current, board[i][j + 1])) return true;
                    }
                }
                
                return false;
            }
        };

        // Bonus Card Manager
        const BonusCardManager = {
            currentBonus: null,
            isCardOpen: false,

            getBonusInfo(bonusType) {
                const bonusInfos = {
                    bonus_hold: {
                        icon: 'üßó‚Äç‚ôÇÔ∏è',
                        title: 'Î≥¥ÎÑàÏä§ ÌôÄÎìú!',
                        description: 'V5 ÌôÄÎìúÍ∞Ä Î¨¥ÏûëÏúÑ ÏúÑÏπòÏóê ÏÉùÏÑ±Îê©ÎãàÎã§!'
                    },
                    tile_delete: {
                        icon: 'üóëÔ∏è',
                        title: 'ÌôÄÎìú(ÌÉÄÏùº) ÏÇ≠Ï†ú Ïπ¥Îìú!',
                        description: 'ÎßàÏùåÏóê Ïïà ÎìúÎäî ÌôÄÎìúÎ•º ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§!'
                    },
                    shuffle_card: {
                        icon: 'üé≤',
                        title: 'Î¨¥ÏûëÏúÑ Ïû¨Î∞∞Ïπò Ïπ¥Îìú!',
                        description: 'Î¨¥ÏûëÏúÑÎ°ú Í≤åÏûÑ ÌÉÄÏùºÏùÑ ÏÑûÏùÑ Ïàò ÏûàÏäµÎãàÎã§<br>(ÎÇòÏ§ëÏóê ÏÇ¨Ïö© Í∞ÄÎä•)'
                    },
                    crux: {
                        icon: 'ü™®',
                        title: 'ÌÅ¨Îü≠Ïä§!',
                        description: '3ÌÑ¥ ÎèôÏïà ÏõÄÏßÅÏù¥ÏßÄ ÏïäÎäî Î∞îÏúÑÍ∞Ä ÏÉùÏÑ±Îê©ÎãàÎã§!'
                    }
                };
                return bonusInfos[bonusType] || bonusInfos.bonus_hold;
            },

            showReceiveCard() {
                document.getElementById('bonus-card-receive').style.display = 'flex';
                this.isCardOpen = true;
            },

            hideReceiveCard() {
                document.getElementById('bonus-card-receive').style.display = 'none';
                this.isCardOpen = false;
            },

            showConfirmCard(bonusType) {
                const bonusDisplay = document.getElementById('bonus-card-confirm');
                const icon = document.getElementById('bonus-card-icon');
                const title = document.getElementById('bonus-card-title');
                const description = document.getElementById('bonus-card-description');
                const question = document.getElementById('bonus-card-question');
                const actions = document.getElementById('bonus-card-actions');

                const bonusInfo = this.getBonusInfo(bonusType);
                icon.textContent = bonusInfo.icon;
                title.textContent = bonusInfo.title;
                description.innerHTML = bonusInfo.description;
                
                if (bonusType === 'crux') {
                    question.textContent = 'ÌÅ¨Îü≠Ïä§Í∞Ä ÏûêÎèôÏúºÎ°ú Î∞úÎèôÎê©ÎãàÎã§!';
                    actions.style.display = 'none';
                    setTimeout(() => {
                        this.addCrux();
                        this.hideConfirmCard();
                        this.currentBonus = null;
                    }, 2000);
                } else {
                    question.textContent = 'ÏÇ¨Ïö©ÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
                    actions.style.display = 'flex';
                }

                bonusDisplay.style.display = 'flex';
                this.isCardOpen = true;
            },

            hideConfirmCard() {
                const bonusDisplay = document.getElementById('bonus-card-confirm');
                const actions = document.getElementById('bonus-card-actions');
                
                if (bonusDisplay) {
                    bonusDisplay.style.display = 'none';
                }
                if (actions) {
                    actions.style.display = 'flex';
                }
                this.isCardOpen = false;
            },

            openCard() {
                this.hideReceiveCard();
                if (this.currentBonus) {
                    this.showConfirmCard(this.currentBonus);
                }
            },

            discardCard() {
                this.hideReceiveCard();
                this.currentBonus = null;
                UI.showAchievement('Î≥¥ÎÑàÏä§ Ïπ¥ÎìúÎ•º Î≤ÑÎ†∏ÏäµÎãàÎã§.');
            },

            confirmUse() {
                if (!this.currentBonus) return;

                switch (this.currentBonus) {
                    case 'bonus_hold':
                        this.addBonusHold();
                        break;
                    case 'tile_delete':
                        TileDeleteManager.startDeleteMode();
                        break;
                    case 'shuffle_card':
                        ShuffleManager.giveShuffleCard();
                        break;
                    case 'crux':
                        break;
                }

                if (this.currentBonus !== 'tile_delete' && this.currentBonus !== 'crux') {
                    this.hideConfirmCard();
                    this.currentBonus = null;
                }
            },

            declineUse() {
                this.hideConfirmCard();
                this.currentBonus = null;
                UI.showAchievement('Î≥¥ÎÑàÏä§ Ïπ¥ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
            },

            showRandomBonus() {
                const bonusTypes = CONFIG.BONUS_TYPES;
                const randomIndex = Math.floor(Math.random() * bonusTypes.length);
                this.currentBonus = bonusTypes[randomIndex];
                this.showReceiveCard();
            },

            addBonusHold() {
                const emptyCells = Utils.getEmptyCells(Game.board);
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    Game.board[randomCell.x][randomCell.y] = 6; // V5
                    UI.showAchievement('Î≥¥ÎÑàÏä§ V5 ÌôÄÎìú ÏÉùÏÑ±!');
                    RenderManager.renderWithNewTileAnimation(Game.board, [{x: randomCell.x, y: randomCell.y}]);
                }
            },

            addCrux() {
                const emptyCells = Utils.getEmptyCells(Game.board);
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    Game.board[randomCell.x][randomCell.y] = {
                        type: 'crux',
                        remaining: 3
                    };
                    UI.showAchievement('ÌÅ¨Îü≠Ïä§ ÏÉùÏÑ±! 3ÌÑ¥ ÌõÑ ÏÇ¨ÎùºÏßëÎãàÎã§');
                    RenderManager.renderWithNewTileAnimation(Game.board, [{x: randomCell.x, y: randomCell.y}]);
                }
            }
        };

        // Tile Delete Manager
        const TileDeleteManager = {
            isDeleteMode: false,

            startDeleteMode() {
                BonusCardManager.hideConfirmCard();
                this.enableDeleteMode();
                this.isDeleteMode = true;
                BonusCardManager.currentBonus = null;
            },

            enableDeleteMode() {
                document.getElementById('tile-delete-mode').style.display = 'flex';
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / CONFIG.BOARD_SIZE);
                    const col = index % CONFIG.BOARD_SIZE;
                    const tileValue = Game.board[row][col];
                    
                    if (Utils.isDeletableTile(tileValue)) {
                        tile.classList.add('clickable');
                    }
                });
                BonusCardManager.isCardOpen = true;
            },

            disableDeleteMode() {
                document.getElementById('tile-delete-mode').style.display = 'none';
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach(tile => {
                    tile.classList.remove('clickable');
                });
                BonusCardManager.isCardOpen = false;
            },

            deleteTile(row, col) {
                if (this.isDeleteMode && Utils.isDeletableTile(Game.board[row][col])) {
                    Game.board[row][col] = 0;
                    UI.showAchievement('ÌÉÄÏùºÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!');
                    RenderManager.renderBoard(Game.board);
                    this.cancel();
                }
            },

            cancel() {
                this.isDeleteMode = false;
                this.disableDeleteMode();
            }
        };

        // Shuffle Manager
        const ShuffleManager = {
            giveShuffleCard() {
                Game.hasShuffle = true;
                this.showShuffleButton();
                UI.showAchievement('Î¨¥ÏûëÏúÑ Ïû¨Î∞∞Ïπò Ïπ¥Îìú ÌöçÎìù!');
            },

            showShuffleButton() {
                document.getElementById('shuffle-btn').style.display = 'inline-block';
            },

            hideShuffleButton() {
                document.getElementById('shuffle-btn').style.display = 'none';
            },

            shuffle() {
                if (Game.hasShuffle) {
                    const tiles = [];
                    const positions = [];
                    
                    for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                        for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                            if (Game.board[i][j] !== 0) {
                                tiles.push(Game.board[i][j]);
                                positions.push({x: i, y: j});
                            }
                        }
                    }
                    
                    // Fisher-Yates shuffle
                    for (let i = tiles.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                    }
                    
                    // Clear board
                    for (let pos of positions) {
                        Game.board[pos.x][pos.y] = 0;
                    }
                    
                    // Place shuffled tiles
                    for (let i = 0; i < tiles.length; i++) {
                        const pos = positions[i];
                        Game.board[pos.x][pos.y] = tiles[i];
                    }
                    
                    Game.hasShuffle = false;
                    this.hideShuffleButton();
                    UI.showAchievement('ÌÉÄÏùºÏù¥ Î¨¥ÏûëÏúÑÎ°ú Ïû¨Î∞∞ÏπòÎêòÏóàÏäµÎãàÎã§!');
                    
                    RenderManager.renderBoard(Game.board);
                }
            }
        };

        // Main Game Class
        class BoulderMasterGame {
            constructor() {
                this.board = Utils.createEmptyBoard();
                this.gameOver = false;
                this.moveCount = 0;
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem(CONFIG.STORAGE_KEY) || '0');
                this.hasShuffle = false;
                this.bonusCardEnabled = true;
                
                this.skills = {
                    grip: false,
                    core: false,
                    dynamic: false,
                    balance: false
                };
                this.skillCount = 0;
                this.initialized = false;
            }
            
            init() {
                if (!this.initialized) {
                    this.addRandomTile();
                    this.addRandomTile();
                    this.initialized = true;
                }
                this.updateDisplay();
                RenderManager.renderBoard(this.board);
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.removeEventListeners();

                this.keydownHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    
                    const keyActions = {
                        'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                        'ArrowDown': 'down', 's': 'down', 'S': 'down',
                        'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                        'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                    };
                    
                    const direction = keyActions[e.key];
                    if (direction) {
                        e.preventDefault();
                        this.handleMove(direction);
                    }
                };
                
                document.addEventListener('keydown', this.keydownHandler);

                this.setupTouchEvents();
                this.setupMouseEvents();
            }

            setupTouchEvents() {
                this.touchStartX = 0;
                this.touchStartY = 0;

                const gameContainer = document.getElementById('game-container');
                
                this.touchStartHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    
                    if (e.target.closest('.btn')) {
                        this.touchStartX = null;
                        this.touchStartY = null;
                        return;
                    }

                    const touch = e.touches[0] || e.changedTouches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                };

                this.touchMoveHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    e.preventDefault();
                };

                this.touchEndHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    
                    if (this.touchStartX === null || this.touchStartY === null) {
                        return;
                    }

                    e.preventDefault();
                    
                    const touch = e.changedTouches[0];
                    const touchEndX = touch.clientX;
                    const touchEndY = touch.clientY;
                    
                    this.handleSwipe(this.touchStartX, this.touchStartY, touchEndX, touchEndY);
                };

                gameContainer.addEventListener('touchstart', this.touchStartHandler, { passive: false });
                gameContainer.addEventListener('touchmove', this.touchMoveHandler, { passive: false });
                gameContainer.addEventListener('touchend', this.touchEndHandler, { passive: false });
            }

            setupMouseEvents() {
                this.mouseStartX = 0;
                this.mouseStartY = 0;
                this.isMouseDown = false;

                const gameBoard = document.getElementById('game-board');

                this.mouseDownHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    e.preventDefault();
                    this.isMouseDown = true;
                    this.mouseStartX = e.clientX;
                    this.mouseStartY = e.clientY;
                };

                this.mouseUpHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || !this.isMouseDown || TileDeleteManager.isDeleteMode) return;
                    e.preventDefault();
                    this.isMouseDown = false;
                    const mouseEndX = e.clientX;
                    const mouseEndY = e.clientY;
                    this.handleSwipe(this.mouseStartX, this.mouseStartY, mouseEndX, mouseEndY);
                };

                this.mouseLeaveHandler = () => {
                    this.isMouseDown = false;
                };

                gameBoard.addEventListener('mousedown', this.mouseDownHandler);
                gameBoard.addEventListener('mouseup', this.mouseUpHandler);
                gameBoard.addEventListener('mouseleave', this.mouseLeaveHandler);
            }

            removeEventListeners() {
                if (this.keydownHandler) {
                    document.removeEventListener('keydown', this.keydownHandler);
                }
                
                const gameContainer = document.getElementById('game-container');
                const gameBoard = document.getElementById('game-board');
                
                if (this.touchStartHandler) {
                    gameContainer.removeEventListener('touchstart', this.touchStartHandler);
                }
                if (this.touchMoveHandler) {
                    gameContainer.removeEventListener('touchmove', this.touchMoveHandler);
                }
                if (this.touchEndHandler) {
                    gameContainer.removeEventListener('touchend', this.touchEndHandler);
                }
                if (this.mouseDownHandler) {
                    gameBoard.removeEventListener('mousedown', this.mouseDownHandler);
                }
                if (this.mouseUpHandler) {
                    gameBoard.removeEventListener('mouseup', this.mouseUpHandler);
                }
                if (this.mouseLeaveHandler) {
                    gameBoard.removeEventListener('mouseleave', this.mouseLeaveHandler);
                }
            }

            handleSwipe(startX, startY, endX, endY) {
                const minSwipeDistance = 50;
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                    return;
                }
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 0) {
                        this.handleMove('right');
                    } else {
                        this.handleMove('left');
                    }
                } else {
                    if (deltaY > 0) {
                        this.handleMove('down');
                    } else {
                        this.handleMove('up');
                    }
                }
            }

            handleMove(direction) {
                RenderManager.removeNewTileMarkers();
                
                const boardBefore = Utils.deepCopyBoard(this.board);
                const result = GameLogic.moveBoard(this.board, direction);
                
                if (result.moved) {
                    this.moveCount++;
                    
                    Utils.processCruxTiles(this.board);
                    
                    this.convertV7ToSkill();
                    this.calculateScore(result);
                    this.processSkillAcquisition();
                    
                    const emptyCellsBefore = Utils.getEmptyCells(this.board);
                    this.addRandomTile();
                    const emptyCellsAfter = Utils.getEmptyCells(this.board);
                    
                    const newTilePositions = this.findNewTilePositions(emptyCellsBefore, emptyCellsAfter);
                    
                    this.updateDisplay();
                    RenderManager.renderWithNewTileAnimation(this.board, newTilePositions);
                    
                    if (this.bonusCardEnabled && this.moveCount % CONFIG.BONUS_INTERVAL === 0) {
                        setTimeout(() => {
                            BonusCardManager.showRandomBonus();
                        }, 500);
                    }
                    
                    this.checkGameState();
                }
            }

            findNewTilePositions(emptyCellsBefore, emptyCellsAfter) {
                const newPositions = [];
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const wasEmpty = emptyCellsBefore.some(cell => cell.x === i && cell.y === j);
                        const isEmptyNow = emptyCellsAfter.some(cell => cell.x === i && cell.y === j);
                        
                        if (wasEmpty && !isEmptyNow) {
                            newPositions.push({x: i, y: j});
                        }
                    }
                }
                
                return newPositions;
            }

            calculateScore(result) {
                if (result.merges > 1) {
                    const comboBonus = result.merges * 100;
                    UI.showAchievement(`${result.merges}Ïó∞ÏÜç ÏôÑÎì±! +${comboBonus}`);
                    this.addScore(comboBonus);
                }
            }

            addScore(points) {
                this.score += points;
                this.updateBestScore();
                UI.updateScore(this.score);
            }

            updateBestScore() {
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem(CONFIG.STORAGE_KEY, this.bestScore.toString());
                    UI.updateBestScore(this.bestScore);
                }
            }
            
            processSkillAcquisition() {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const cell = this.board[i][j];
                        if (Utils.isSkillTile(cell)) {
                            const skillType = Utils.getSkillType(cell);
                            if (this.acquireSkill(skillType)) {
                                this.addScore(500);
                            }
                        }
                    }
                }
            }

            acquireSkill(skillType) {
                if (!this.skills[skillType]) {
                    this.skills[skillType] = true;
                    UI.showAchievement(`${CONFIG.SKILL_NAMES[skillType]} Ïä§ÌÇ¨ ÌöçÎìù!`);
                    UI.updateSkillsDisplay(this.skills);
                    return true;
                }
                return false;
            }

            hasAllSkills() {
                return Object.values(this.skills).every(skill => skill);
            }

            convertV7ToSkill() {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (this.board[i][j] === CONFIG.V7_VALUE && this.skillCount < 4) {
                            const skillTile = this.generateSkillTile();
                            if (typeof skillTile === 'string') {
                                this.board[i][j] = skillTile;
                                this.skillCount++;
                            }
                        }
                    }
                }
            }

            generateSkillTile() {
                if (this.skillCount < 4) {
                    return `skill-${CONFIG.SKILL_TYPES[this.skillCount]}`;
                }
                return CONFIG.V7_VALUE;
            }
            
            addRandomTile() {
                const emptyCells = Utils.getEmptyCells(this.board);
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.board[randomCell.x][randomCell.y] = Utils.getRandomTile();
                }
            }
            
            checkGameState() {
                if (this.hasAllSkills()) {
                    setTimeout(() => this.endGame(true), 500);
                    return;
                }
                
                if (!GameLogic.hasAvailableMoves(this.board)) {
                    this.gameOver = true;
                    setTimeout(() => this.endGame(false), 300);
                }
            }
            
            endGame(won) {
                this.gameOver = true;
                UI.showGameOver(won, this.score);
            }

            newGame() {
                this.board = Utils.createEmptyBoard();
                this.gameOver = false;
                this.moveCount = 0;
                this.score = 0;
                this.hasShuffle = false;
                
                this.skills = {
                    grip: false,
                    core: false,
                    dynamic: false,
                    balance: false
                };
                this.skillCount = 0;
                
                // Reset managers
                TileDeleteManager.isDeleteMode = false;
                BonusCardManager.isCardOpen = false;
                BonusCardManager.currentBonus = null;
                
                // Hide all modals and overlays
                UI.hideGameOver();
                ShuffleManager.hideShuffleButton();
                TileDeleteManager.disableDeleteMode();
                BonusCardManager.hideReceiveCard();
                BonusCardManager.hideConfirmCard();
                
                this.addRandomTile();
                this.addRandomTile();
                this.updateDisplay();
                RenderManager.renderBoard(this.board);
            }
            
            updateDisplay() {
                UI.updateScore(this.score);
                UI.updateBestScore(this.bestScore);
                UI.updateMoveCount(this.moveCount);
                UI.updateSkillsDisplay(this.skills);
            }
        }

        // Game Controller
        const GameController = {
            game: null,

            startGame() {
                const bonusCardEnabled = document.getElementById('bonus-card-enabled').checked;
                
                UI.hideMainMenu();
                UI.hideGuide();
                
                if (!this.game) {
                    this.game = new BoulderMasterGame();
                }
                
                this.game.bonusCardEnabled = bonusCardEnabled;
                this.game.init();
            },

            newGame() {
                if (this.game) {
                    this.game.newGame();
                } else {
                    this.game = new BoulderMasterGame();
                    this.game.init();
                }
            }
        };

        // Global Game Instance (for backward compatibility)
        let Game = null;

        // Initialize Game Reference
        function initializeGameReference() {
            if (GameController.game) {
                Game = GameController.game;
            }
        }

        // Override GameController methods to update global reference
        const originalStartGame = GameController.startGame;
        const originalNewGame = GameController.newGame;

        GameController.startGame = function() {
            originalStartGame.call(this);
            initializeGameReference();
        };

        GameController.newGame = function() {
            originalNewGame.call(this);
            initializeGameReference();
        };

        // Initialize on page load
        window.addEventListener('load', () => {
            const bestScore = parseInt(localStorage.getItem(CONFIG.STORAGE_KEY) || '0');
            UI.updateBestScore(bestScore);
            
            // PWA ÏÑúÎπÑÏä§ ÏõåÏª§ Îì±Î°ù
            PWAManager.init();
        });

        // PWA Manager
        const PWAManager = {
            init() {
                this.registerServiceWorker();
                this.setupInstallPrompt();
                this.addToHomeScreenPrompt();
            },

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker Îì±Î°ù ÏÑ±Í≥µ:', registration);
                    } catch (error) {
                        console.log('Service Worker Îì±Î°ù Ïã§Ìå®:', error);
                    }
                }
            },

            setupInstallPrompt() {
                let deferredPrompt;

                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    deferredPrompt = e;
                    this.showInstallButton(deferredPrompt);
                });

                window.addEventListener('appinstalled', () => {
                    console.log('PWAÍ∞Ä ÏÑ§ÏπòÎêòÏóàÏäµÎãàÎã§!');
                    this.hideInstallButton();
                });
            },

            showInstallButton(deferredPrompt) {
                // ÏÑ§Ïπò Î≤ÑÌäºÏùÑ Î©îÏù∏ Î©îÎâ¥Ïóê Ï∂îÍ∞Ä
                const openingButtons = document.querySelector('.opening-buttons');
                if (openingButtons && !document.getElementById('install-btn')) {
                    const installBtn = document.createElement('button');
                    installBtn.id = 'install-btn';
                    installBtn.className = 'btn warning';
                    installBtn.innerHTML = 'üì± Ïï±ÏúºÎ°ú ÏÑ§ÏπòÌïòÍ∏∞';
                    installBtn.onclick = () => this.installApp(deferredPrompt);
                    
                    // Í∞ÄÏù¥Îìú Î≤ÑÌäº ÏïûÏóê Ï∂îÍ∞Ä
                    const guideBtn = openingButtons.querySelector('button:last-child');
                    openingButtons.insertBefore(installBtn, guideBtn);
                }
            },

            hideInstallButton() {
                const installBtn = document.getElementById('install-btn');
                if (installBtn) {
                    installBtn.remove();
                }
            },

            async installApp(deferredPrompt) {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('ÏÑ§Ïπò Í≤∞Í≥º:', outcome);
                    deferredPrompt = null;
                    this.hideInstallButton();
                }
            },

            addToHomeScreenPrompt() {
                // iOS SafariÏö© ÏÑ§Ïπò ÏïàÎÇ¥
                if (this.isIOS() && !this.isInStandaloneMode()) {
                    setTimeout(() => {
                        if (!localStorage.getItem('ios-install-prompt-shown')) {
                            UI.showAchievement('SafariÏóêÏÑú "Ìôà ÌôîÎ©¥Ïóê Ï∂îÍ∞Ä"Î°ú Ïï±Ï≤òÎüº ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî!');
                            localStorage.setItem('ios-install-prompt-shown', 'true');
                        }
                    }, 3000);
                }
            },

            isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent);
            },

            isInStandaloneMode() {
                return window.matchMedia('(display-mode: standalone)').matches ||
                       window.navigator.standalone === true;
            }
        };
    </script>
</body>
</html>
