// Initialize on page load
        window.addEventListener('load', () => {
            const bestScore = parseInt(localStorage.getItem(CONFIG.STORAGE_KEY) || '0');
            UI.updateBestScore(bestScore);
            
            // PWA ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡
            PWAManager.init();
        });

        // PWA Manager
        const PWAManager = {
            init() {
                this.registerServiceWorker();
                this.setupInstallPrompt();
                this.addToHomeScreenPrompt();
            },

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('sw.js');
                        console.log('Service Worker ë“±ë¡ ì„±ê³µ:', registration);
                    } catch (error) {
                        console.log('Service Worker ë“±ë¡ ì‹¤íŒ¨:', error);
                    }
                }
            },

            setupInstallPrompt() {
                let deferredPrompt;

                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    deferredPrompt = e;
                    this.showInstallButton(deferredPrompt);
                });

                window.addEventListener('appinstalled', () => {
                    console.log('PWAê°€ ì„¤ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    this.hideInstallButton();
                });
            },

            showInstallButton(deferredPrompt) {
                // ì„¤ì¹˜ ë²„íŠ¼ì„ ë©”ì¸ ë©”ë‰´ì— ì¶”ê°€
                const openingButtons = document.querySelector('.opening-buttons');
                if (openingButtons && !document.getElementById('install-btn')) {
                    const installBtn = document.createElement('button');
                    installBtn.id = 'install-btn';
                    installBtn.className = 'btn warning';
                    installBtn.innerHTML = 'ğŸ“± ì•±ìœ¼ë¡œ ì„¤ì¹˜í•˜ê¸°';
                    installBtn.onclick = () => this.installApp(deferredPrompt);
                    
                    // ê°€ì´ë“œ ë²„íŠ¼ ì•ì— ì¶”ê°€
                    const guideBtn = openingButtons.querySelector('button:last-child');
                    openingButtons.insertBefore(installBtn, guideBtn);
                }
            },

            hideInstallButton() {
                const installBtn = document.getElementById('install-btn');
                if (installBtn) {
                    installBtn.remove();
                }
            },

            async installApp(deferredPrompt) {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('ì„¤ì¹˜ ê²°ê³¼:', outcome);
                    deferredPrompt = null;
                    this.hideInstallButton();
                }
            },

            addToHomeScreenPrompt() {
                // iOS Safariìš© ì„¤ì¹˜ ì•ˆë‚´
                if (this.isIOS() && !this.isInStandaloneMode()) {
                    setTimeout(() => {
                        if (!localStorage.getItem('ios-install-prompt-shown')) {
                            UI.showAchievement('Safariì—ì„œ "í™ˆ í™”ë©´ì— ì¶”ê°€"ë¡œ ì•±ì²˜ëŸ¼ ì‚¬ìš©í•˜ì„¸ìš”!');
                            localStorage.setItem('ios-install-prompt-shown', 'true');
                        }
                    }, 3000);
                }
            },

            isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent);
            },

            isInStandaloneMode() {
                return window.matchMedia('(display-mode: standalone)').matches ||
                       window.navigator.standalone === true;
            }
        };
    </script>
    
    <!-- PWA ë§¤ë‹ˆí˜ìŠ¤íŠ¸ íŒŒì¼ì„ ìœ„í•œ ìŠ¤í¬ë¦½íŠ¸ -->
    <script>
        // ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë™ì  ìƒì„± (ì‹¤<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë³¼ë”ë§ 2048 - í´ë¼ì´ë° 2048 ê²Œì„</title>
    <meta name="description" content="í´ë¼ì´ë° í…Œë§ˆì˜ 2048 í¼ì¦ ê²Œì„, ë³¼ë”ë§ 2048! V0ë¶€í„° V7+ê¹Œì§€ í´ë¼ì´ë° ê·¸ë ˆì´ë“œë¥¼ í•©ì¹˜ê³  4ê°€ì§€ ìŠ¤í‚¬ì„ ëª¨ì•„ ë³¼ë”ë§ ë§ˆìŠ¤í„°ê°€ ë˜ì–´ë³´ì„¸ìš”.">
    <meta name="keywords" content="2048, í´ë¼ì´ë°, ë³¼ë”ë§, í¼ì¦ ê²Œì„, ì›¹ê²Œì„, 2048 ê²Œì„, climbing, bouldering, puzzle game">
    
    <meta property="og:title" content="ë³¼ë”ë§ 2048 - í´ë¼ì´ë° 2048 ê²Œì„">
    <meta property="og:description" content="V0ë¶€í„° V7+ê¹Œì§€ í´ë¼ì´ë° ê·¸ë ˆì´ë“œë¥¼ í•©ì³ ë³¼ë”ë§ ë§ˆìŠ¤í„°ì— ë„ì „í•˜ì„¸ìš”!">
    <meta property="og:type" content="website">
    
    <!-- PWA ê´€ë ¨ ë©”íƒ€ íƒœê·¸ -->
    <meta name="theme-color" content="#007bff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ë³¼ë”ë§ 2048">
    
    <!-- PWA ë§¤ë‹ˆí˜ìŠ¤íŠ¸ -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- íŒŒë¹„ì½˜ ë° ì•„ì´ì½˜ -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icon-192.png">
    <link rel="apple-touch-icon" href="/icon-192.png">
    
    <!-- PWA ê´€ë ¨ ë©”íƒ€ íƒœê·¸ -->
    <meta name="theme-color" content="#007bff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ë³¼ë”ë§ 2048">
    
    <!-- PWA ë§¤ë‹ˆí˜ìŠ¤íŠ¸ -->
    <link rel="manifest" href="manifest.json">
    
    <!-- íŒŒë¹„ì½˜ ë° ì•„ì´ì½˜ -->
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ§—â€â™‚ï¸</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ§—â€â™‚ï¸</text></svg>">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --background: #f0f2f5;
            --card-background: #ffffff;
            --border-color: #e0e0e0;
            --text-primary: #333;
            --text-secondary: #6c757d;
            --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 8px 25px rgba(0, 0, 0, 0.15);
            --shadow-heavy: 0 15px 40px rgba(0, 0, 0, 0.1);
            --border-radius: 15px;
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: var(--background);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        /* Common Components */
        .btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-light);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 80px;
            touch-action: manipulation;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-medium);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
        }

        .btn.success {
            background: linear-gradient(135deg, var(--success-color), #2ecc71);
        }

        .btn.danger {
            background: linear-gradient(135deg, var(--danger-color), #c0392b);
        }

        .btn.warning {
            background: linear-gradient(135deg, var(--warning-color), #e67e22);
        }

        /* Opening Screen */
        .opening-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e6f7ff 0%, #ffffff 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 1s ease-in-out;
        }

        .opening-screen.hidden {
            display: none;
        }

        .opening-container {
            background: var(--card-background);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: var(--shadow-heavy);
            border: 1px solid var(--border-color);
            max-width: 400px;
            width: 90%;
            animation: slideUp 0.8s ease-out 0.2s both;
        }

        .opening-title {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .climbing-icon {
            font-size: 3em;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border-radius: var(--border-radius);
            padding: 15px;
            color: white;
            box-shadow: 0 10px 25px rgba(254, 202, 87, 0.3);
        }

        .title-text {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #4a4a4a, #212121);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.1em;
            margin-bottom: 30px;
            color: var(--text-secondary);
        }

        .best-score-display {
            background: #f7f9fa;
            border-radius: var(--border-radius);
            padding: 15px;
            margin: 20px 0;
            border: 1px solid #e0e6ed;
        }

        .best-score-label {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .best-score-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--primary-color);
        }

        .opening-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            cursor: pointer;
            user-select: none;
            color: var(--text-primary);
            font-size: 1em;
            font-weight: 500;
        }

        .checkbox-container input {
            display: none;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            background: #e0e6ed;
            border: 2px solid #ced4da;
            border-radius: 4px;
            margin-right: 10px;
            position: relative;
            transition: var(--transition);
        }

        .checkbox-container input:checked + .checkmark {
            background: var(--primary-color);
            border-color: var(--primary-hover);
        }

        .checkbox-container input:checked + .checkmark::after {
            content: 'âœ“';
            position: absolute;
            left: 3px;
            top: -2px;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        /* Guide Screen */
        .guide-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e6f7ff 0%, #ffffff 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            overflow-y: auto;
        }

        .guide-container {
            background: var(--card-background);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: var(--shadow-heavy);
            border: 1px solid var(--border-color);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .guide-title {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .guide-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .guide-content {
            text-align: left;
        }

        .guide-section {
            background: #f8f9fa;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .guide-section h3 {
            color: var(--primary-color);
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
        }

        .guide-section p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #495057;
            font-size: 0.95em;
        }

        /* Game Container */
        .game-container {
            text-align: center;
            background: var(--card-background);
            border-radius: 20px;
            padding: 20px;
            box-shadow: var(--shadow-heavy);
            border: 1px solid var(--border-color);
            position: relative;
            max-width: 400px;
            width: 100%;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.5s ease;
        }

        .game-container.show {
            opacity: 1;
            transform: translateY(0);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 15px;
            color: #343a40;
            letter-spacing: 1px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 0.8em;
            margin-bottom: 3px;
            color: var(--text-secondary);
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #343a40;
        }

        .skills-container {
            background: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
        }

        .skills-title {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: var(--warning-color);
            font-weight: bold;
        }

        .skills-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .skill-slot {
            background: #e9ecef;
            border: 2px dashed #ced4da;
            border-radius: 10px;
            padding: 10px 5px;
            min-height: 55px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .skill-slot.acquired {
            background: linear-gradient(135deg, var(--success-color), #2ecc71);
            border: 2px solid var(--success-color);
            color: white;
            font-weight: bold;
            animation: skillGlow 2s infinite alternate;
        }

        /* Game Board */
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            background: #e9ecef;
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            border: 1px solid #dee2e6;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            touch-action: none;
            user-select: none;
        }

        .tile {
            aspect-ratio: 1 / 1;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
            border: none;
            position: relative;
            cursor: pointer;
        }

        .tile.empty {
            background: #d6dbe0;
            border: 2px dashed #b8c0c8;
        }

        .tile.new-tile {
            animation: tileAppear 0.4s ease-out;
        }

        .tile.new-tile::before {
            content: 'N';
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 3px;
            padding: 1px 3px;
            font-size: 0.6em;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
        }

        .tile.clickable {
            cursor: pointer;
            border: 3px solid #feca57;
            animation: clickablePulse 1s infinite;
        }

        .tile.crux {
            background: linear-gradient(135deg, var(--secondary-color), #343a40) !important;
            border: 3px solid #495057 !important;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .tile.crux .crux-icon {
            font-size: 1.8em;
            margin-bottom: 2px;
        }

        .tile.crux .crux-counter {
            font-size: 0.7em;
            color: #feca57;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 2px 6px;
            font-weight: bold;
        }

        /* Grade Colors */
        .tile.v0 { 
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            color: white;
        }
        .tile.v1 { 
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }
        .tile.v2 { 
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            box-shadow: 0 4px 15px rgba(241, 196, 15, 0.3);
        }
        .tile.v3 { 
            background: linear-gradient(135deg, #27ae60, #229954);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }
        .tile.v4 { 
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            color: white;
        }
        .tile.v5 { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        .tile.v6 { 
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
            color: white;
        }
        .tile.v7 { 
            background: linear-gradient(135deg, #2c3e50, #34495e);
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.3);
            color: white;
            border: 2px solid #ecf0f1;
        }

        /* Skill Tiles */
        .tile.skill-grip { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #e74c3c);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-core { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #f39c12);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-dynamic { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #27ae60);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }
        .tile.skill-balance { 
            background: linear-gradient(135deg, #2c3e50, #34495e, #3498db);
            animation: skillPulse 2s infinite;
            color: white;
            border: 2px solid #ecf0f1;
        }

        .controls {
            margin: 25px 0 10px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .shuffle-btn {
            background: #9b59b6;
            font-size: 1.2em;
            padding: 10px 20px;
        }

        .shuffle-btn:hover {
            background: #8e44ad;
        }

        /* Modal Components */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--card-background);
            color: var(--text-primary);
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            max-width: 400px;
        }

        /* Bonus Card */
        .bonus-card-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            z-index: 1500;
            height: 100%;
            pointer-events: none;
        }

        .bonus-card-content {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            max-width: 350px;
            width: 90%;
            animation: cardSlideDown 0.5s ease;
            color: white;
            pointer-events: auto;
        }

        .bonus-card-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .bonus-card-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 1px 1px 5px rgba(0,0,0,0.2);
        }

        .bonus-card-description {
            font-size: 1em;
            margin-bottom: 20px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }

        .bonus-card-question {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }

        .bonus-card-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .bonus-card-actions .btn {
            padding: 10px 20px;
            font-size: 0.9em;
            min-width: 60px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* Achievement Display */
        .achievement-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--success-color), #2ecc71);
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            font-weight: bold;
            opacity: 0;
            transition: var(--transition);
            z-index: 100;
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .achievement-display.show {
            opacity: 1;
            animation: achievementShow 3s ease;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes tileAppear {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes skillGlow {
            0% { box-shadow: 0 0 5px rgba(39, 174, 96, 0.5); }
            100% { box-shadow: 0 0 20px rgba(39, 174, 96, 0.8); }
        }

        @keyframes skillPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(44, 62, 80, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 25px rgba(44, 62, 80, 0.8);
            }
        }

        @keyframes clickablePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes cardSlideDown {
            from { 
                transform: translateY(-50px) scale(0.8);
                opacity: 0;
            }
            to { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes achievementShow {
            0% { 
                transform: translateX(100px) scale(0.8); 
                opacity: 0; 
            }
            20%, 80% { 
                transform: translateX(0) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translateX(100px) scale(0.8); 
                opacity: 0; 
            }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .guide-container {
                padding: 25px;
                margin: 10px;
            }
            
            .guide-section {
                padding: 15px;
            }

            .game-container {
                padding: 15px;
            }

            .game-board {
                gap: 8px;
                padding: 10px;
            }

            .opening-container {
                padding: 30px 25px;
            }

            .title-text {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <!-- Opening Screen -->
    <div class="opening-screen" id="opening-screen">
        <div class="opening-container">
            <div class="opening-title">
                <div class="climbing-icon">ğŸ§—â€â™‚ï¸</div>
                <div class="title-text">ë³¼ë”ë§ 2048</div>
            </div>
            
            <div class="subtitle">í´ë¼ì´ë° ê·¸ë ˆì´ë“œë¥¼ ì •ë³µí•˜ë¼!!!</div>
            
            <div class="best-score-display">
                <div class="best-score-label">ìµœê³  ì ìˆ˜</div>
                <div class="best-score-value" id="opening-best-score">0</div>
            </div>
            
            <div class="opening-buttons">
                <button class="btn primary" onclick="GameController.startGame()">
                    ğŸ¯ ìƒˆ ê²Œì„ ì‹œì‘
                </button>
                
                <label class="checkbox-container">
                    <input type="checkbox" id="bonus-card-enabled" checked>
                    <span class="checkmark"></span>
                    <span class="checkbox-text">ë³´ë„ˆìŠ¤ ì¹´ë“œ ë“±ì¥</span>
                </label>
                
                <button class="btn" onclick="UI.showGuide()">
                    ğŸ“– ê°€ì´ë“œ ë³´ê¸°
                </button>
            </div>
        </div>
    </div>

    <!-- Guide Screen -->
    <div class="guide-screen" id="guide-screen">
        <div class="guide-container">
            <div class="guide-title">
                <div class="climbing-icon">ğŸ§—â€â™‚ï¸</div>
                <div class="title-text">í´ë¼ì´ë° ê°€ì´ë“œ</div>
            </div>
            
            <div class="guide-buttons">
                <button class="btn primary" onclick="GameController.startGame()">
                    ğŸ¯ ê²Œì„ ì‹œì‘í•˜ê¸°
                </button>
                <button class="btn" onclick="UI.showMainMenu()">
                    ğŸ  ë©”ì¸ë©”ë‰´ ê°€ê¸°
                </button>
            </div>
            
            <div class="guide-content">
                <div class="guide-section">
                    <h3>ğŸ® ì¡°ì‘ë²•</h3>
                    <p><strong>í™”ì‚´í‘œ í‚¤</strong>, <strong>WASD</strong> ë˜ëŠ” <strong>ìŠ¤ì™€ì´í”„</strong>ë¡œ í™€ë“œë¥¼ ì›€ì§ì´ì„¸ìš”</p>
                    <p><strong>ê°™ì€ ê·¸ë ˆì´ë“œ</strong>ë¥¼ í•©ì³ì„œ <strong>ìƒìœ„ ê·¸ë ˆì´ë“œ</strong>ë¡œ ì—…ê·¸ë ˆì´ë“œí•˜ì„¸ìš”</p>
                    <p><strong>V0</strong> â†’ <strong>V1</strong> â†’ <strong>V2</strong> â†’ <strong>V3</strong> â†’ <strong>V4</strong> â†’ <strong>V5</strong> â†’ <strong>V6</strong> â†’ <strong>V7+</strong></p>
                </div>
                
                <div class="guide-section">
                    <h3>ğŸ† ëª©í‘œ</h3>
                    <p><strong>V7+</strong>ë¥¼ ë§Œë“¤ë©´ ìˆœì„œëŒ€ë¡œ <strong>ìŠ¤í‚¬</strong>ì„ íšë“í•©ë‹ˆë‹¤</p>
                    <p><strong>ğŸ’ª ê·¸ë¦½ë ¥</strong> â†’ <strong>ğŸ‹ï¸ ì½”ì–´</strong> â†’ <strong>ğŸš€ ë‹¤ì´ë‚˜ë¯¹</strong> â†’ <strong>âš–ï¸ ë°¸ëŸ°ìŠ¤</strong></p>
                    <p><strong>4ê°€ì§€ ìŠ¤í‚¬</strong>ì„ ëª¨ë‘ ìˆ˜ì§‘í•˜ë©´ <strong>í´ë¼ì´ë° ë§ˆìŠ¤í„°</strong>!</p>
                </div>
                
                <div class="guide-section">
                    <h3>ğŸ ë³´ë„ˆìŠ¤ ì¹´ë“œ (10ë²ˆ ì›€ì§ì¼ ë•Œë§ˆë‹¤)</h3>
                    <p><strong>ğŸ§—â€â™‚ï¸ ë³´ë„ˆìŠ¤ í™€ë“œ:</strong> V5 íƒ€ì¼ì´ ë¬´ì‘ìœ„ ìœ„ì¹˜ì— ìƒì„±</p>
                    <p><strong>ğŸ—‘ï¸ í™€ë“œ(íƒ€ì¼) ì‚­ì œ:</strong> ë§ˆìŒì— ì•ˆ ë“œëŠ” í™€ë“œë¥¼ ì‚­ì œ</p>
                    <p><strong>ğŸ² ë¬´ì‘ìœ„ ì¬ë°°ì¹˜:</strong> ëª¨ë“  íƒ€ì¼ì„ ì„ì–´ì„œ ì¬ë°°ì¹˜</p>
                    <p><strong>ğŸª¨ í¬ëŸ­ìŠ¤:</strong> 3í„´ ë™ì•ˆ ì›€ì§ì´ì§€ ì•ŠëŠ” ë°”ìœ„ ìƒì„±</p>
                </div>
                
                <div class="guide-section">
                    <h3>ğŸ¯ íŒ</h3>
                    <p>ì—°ì†ìœ¼ë¡œ í•©ì¹˜ë©´ <strong>ì½¤ë³´ ë³´ë„ˆìŠ¤</strong>ë¥¼ íšë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
                    <p>ìŠ¤í‚¬ íƒ€ì¼ì€ íŠ¹ë³„í•œ <strong>ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼</strong>ë¡œ í‘œì‹œë©ë‹ˆë‹¤</p>
                    <p>ë³´ë„ˆìŠ¤ ì¹´ë“œëŠ” ì„ íƒì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
                    <p>ì „ëµì ìœ¼ë¡œ ì›€ì§ì—¬ì„œ <strong>ìµœê³  ì ìˆ˜</strong>ì— ë„ì „í•´ë³´ì„¸ìš”!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="game-container">
        <!-- Bonus Card Displays -->
        <div class="bonus-card-display" id="bonus-card-receive">
            <div class="bonus-card-content">
                <div class="bonus-card-icon">ğŸ</div>
                <div class="bonus-card-title">ë³´ë„ˆìŠ¤ ì¹´ë“œ íšë“!</div>
                <div class="bonus-card-description">10í„´ë§ˆë‹¤ ë°›ëŠ” íŠ¹ë³„í•œ ë³´ë„ˆìŠ¤ ì¹´ë“œì…ë‹ˆë‹¤!</div>
                <div class="bonus-card-question">ì¹´ë“œë¥¼ ì—´ì–´ë³´ì‹œê² ìŠµë‹ˆê¹Œ?</div>
                <div class="bonus-card-actions">
                    <button class="btn success" onclick="BonusCardManager.openCard()">ì¹´ë“œ ì—´ê¸°</button>
                    <button class="btn danger" onclick="BonusCardManager.discardCard()">ë²„ë¦¬ê¸°</button>
                </div>
            </div>
        </div>

        <div class="bonus-card-display" id="bonus-card-confirm">
            <div class="bonus-card-content">
                <div class="bonus-card-icon" id="bonus-card-icon">ğŸ</div>
                <div class="bonus-card-title" id="bonus-card-title">ë³´ë„ˆìŠ¤ ì¹´ë“œ!</div>
                <div class="bonus-card-description" id="bonus-card-description">ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤!</div>
                <div class="bonus-card-question" id="bonus-card-question">ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
                <div class="bonus-card-actions" id="bonus-card-actions">
                    <button class="btn success" onclick="BonusCardManager.confirmUse()">ì˜ˆ</button>
                    <button class="btn danger" onclick="BonusCardManager.declineUse()">ì•„ë‹ˆì˜¤</button>
                </div>
            </div>
        </div>

        <div class="bonus-card-display" id="tile-delete-mode" style="display: none;">
            <div class="bonus-card-content" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);">
                <div class="bonus-card-icon" style="color: #d63384;">ğŸ—‘ï¸</div>
                <div class="bonus-card-title" style="color: #d63384;">íƒ€ì¼ ì‚­ì œ</div>
                <div class="bonus-card-description" style="color: #333;">ì–´ëŠ íƒ€ì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>ì‚­ì œí•  íƒ€ì¼ì„ í´ë¦­í•´ì£¼ì„¸ìš”.</div>
                <div class="bonus-card-actions">
                    <button class="btn" onclick="TileDeleteManager.cancel()">ì·¨ì†Œ</button>
                </div>
            </div>
        </div>

        <h1>ğŸ§—â€â™‚ï¸ Boulder Master</h1>
        
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">ì ìˆ˜</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ìµœê³  ì ìˆ˜</div>
                <div class="stat-value" id="best-score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ì›€ì§ì„</div>
                <div class="stat-value" id="move-count">0</div>
            </div>
        </div>

        <div class="skills-container">
            <div class="skills-title">ğŸ¯ í´ë¼ì´ë° ìŠ¤í‚¬ ìˆ˜ì§‘</div>
            <div class="skills-grid">
                <div class="skill-slot" id="skill-grip">
                    <div>ğŸ’ª</div>
                    <div>ê·¸ë¦½ë ¥</div>
                </div>
                <div class="skill-slot" id="skill-core">
                    <div>ğŸ‹ï¸</div>
                    <div>ì½”ì–´</div>
                </div>
                <div class="skill-slot" id="skill-dynamic">
                    <div>ğŸš€</div>
                    <div>ë‹¤ì´ë‚˜ë¯¹</div>
                </div>
                <div class="skill-slot" id="skill-balance">
                    <div>âš–ï¸</div>
                    <div>ë°¸ëŸ°ìŠ¤</div>
                </div>
            </div>
        </div>

        <div class="game-board" id="game-board"></div>

        <div class="controls">
            <button class="btn primary" onclick="GameController.newGame()">ìƒˆ ê²Œì„</button>
            <button class="btn" onclick="UI.showMainMenu()">ë©”ì¸ ë©”ë‰´</button>
            <button class="btn shuffle-btn" id="shuffle-btn" onclick="ShuffleManager.shuffle()" style="display: none;">ğŸ²</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal-overlay" id="game-over">
        <div class="modal-content">
            <h2 id="game-over-title">ì„¸ì…˜ ì¢…ë£Œ!</h2>
            <p id="game-over-message"></p>
            <p>ì ìˆ˜: <span id="final-score"></span></p>
            <button class="btn primary" onclick="GameController.newGame()">ë‹¤ì‹œ ë„ì „</button>
            <button class="btn" onclick="UI.showMainMenu()">ë©”ì¸ í™”ë©´</button>
        </div>
    </div>

    <!-- Achievement Display -->
    <div class="achievement-display" id="achievement-display"></div>

    <script>
        // Game Configuration
        const CONFIG = {
            BOARD_SIZE: 4,
            SKILL_TYPES: ['grip', 'core', 'dynamic', 'balance'],
            GRADES: ['empty', 'v0', 'v1', 'v2', 'v3', 'v4', 'v5', 'v6', 'v7'],
            GRADE_NAMES: ['', 'V0', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7+'],
            SKILL_NAMES: {
                grip: 'ğŸ’ª ê·¸ë¦½ë ¥',
                core: 'ğŸ‹ï¸ ì½”ì–´',
                dynamic: 'ğŸš€ ë‹¤ì´ë‚˜ë¯¹',
                balance: 'âš–ï¸ ë°¸ëŸ°ìŠ¤'
            },
            BONUS_TYPES: ['bonus_hold', 'tile_delete', 'shuffle_card', 'crux'],
            STORAGE_KEY: 'boulderMasterBest',
            V7_VALUE: 8,
            MAX_MERGEABLE_VALUE: 7,
            BONUS_INTERVAL: 10
        };

        // Utility Functions
        const Utils = {
            createEmptyBoard() {
                return Array(CONFIG.BOARD_SIZE).fill()
                    .map(() => Array(CONFIG.BOARD_SIZE).fill(0));
            },

            deepCopyBoard(board) {
                return board.map(row => [...row]);
            },

            getRandomTile() {
                return Math.random() < 0.9 ? 1 : 2; // 90% V0, 10% V1
            },

            getEmptyCells(board) {
                const emptyCells = [];
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (board[i][j] === 0) {
                            emptyCells.push({x: i, y: j});
                        }
                    }
                }
                return emptyCells;
            },

            isSkillTile(value) {
                return typeof value === 'string' && value.startsWith('skill-');
            },

            getSkillType(skillTile) {
                return skillTile.split('-')[1];
            },

            isCruxTile(value) {
                return typeof value === 'object' && value && value.type === 'crux';
            },

            isDeletableTile(value) {
                return value !== 0 && !this.isCruxTile(value) && !this.isSkillTile(value);
            },

            processCruxTiles(board) {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (this.isCruxTile(board[i][j])) {
                            board[i][j].remaining--;
                            if (board[i][j].remaining <= 0) {
                                board[i][j] = 0;
                            }
                        }
                    }
                }
            }
        };

        // UI Manager
        const UI = {
            updateScore(score) {
                document.getElementById('score').textContent = score;
            },
            
            updateBestScore(bestScore) {
                document.getElementById('best-score').textContent = bestScore;
                document.getElementById('opening-best-score').textContent = bestScore;
            },

            updateMoveCount(count) {
                document.getElementById('move-count').textContent = count;
            },
            
            updateSkillsDisplay(skills) {
                Object.keys(skills).forEach(skill => {
                    const element = document.getElementById(`skill-${skill}`);
                    element.classList.toggle('acquired', skills[skill]);
                });
            },
            
            showAchievement(message) {
                const achievementDisplay = document.getElementById('achievement-display');
                achievementDisplay.textContent = message;
                achievementDisplay.classList.add('show');
                setTimeout(() => {
                    achievementDisplay.classList.remove('show');
                }, 3000);
            },
            
            showGameOver(won, score) {
                const gameOverDiv = document.getElementById('game-over');
                const title = document.getElementById('game-over-title');
                const message = document.getElementById('game-over-message');
                const finalScore = document.getElementById('final-score');
                
                if (won) {
                    title.textContent = 'ğŸ† í´ë¼ì´ë° ë§ˆìŠ¤í„°! ğŸ†';
                    message.textContent = '4ê°€ì§€ ìŠ¤í‚¬ì„ ëª¨ë‘ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ë‹¹ì‹ ì€ ì§„ì •í•œ ë³¼ë”ë§ ê³ ìˆ˜ì…ë‹ˆë‹¤!';
                } else {
                    title.textContent = 'ì„¸ì…˜ ì¢…ë£Œ';
                    message.textContent = 'ë” ì´ìƒ í™€ë“œë¥¼ ì¡ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
                }
                
                finalScore.textContent = score;
                gameOverDiv.style.display = 'flex';
            },
            
            hideGameOver() {
                document.getElementById('game-over').style.display = 'none';
            },

            showMainMenu() {
                document.getElementById('opening-screen').style.display = 'flex';
                document.getElementById('guide-screen').style.display = 'none';
                document.getElementById('game-container').classList.remove('show');
            },

            hideMainMenu() {
                document.getElementById('opening-screen').style.display = 'none';
                setTimeout(() => {
                    document.getElementById('game-container').classList.add('show');
                }, 300);
            },

            showGuide() {
                document.getElementById('guide-screen').style.display = 'flex';
                document.getElementById('opening-screen').style.display = 'none';
                document.getElementById('game-container').classList.remove('show');
            },

            hideGuide() {
                document.getElementById('guide-screen').style.display = 'none';
            }
        };

        // Render Manager
        const RenderManager = {
            renderBoard(board, animateNewTiles = false) {
                const boardElement = document.getElementById('game-board');
                boardElement.innerHTML = '';
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const tile = this.createTileElement(board[i][j], animateNewTiles);
                        boardElement.appendChild(tile);
                    }
                }
                this.setupTileClickHandlers();
            },
            
            createTileElement(value, isNewTile = false) {
                const tile = document.createElement('div');
                
                if (value === 0) {
                    tile.className = 'tile empty';
                } else if (Utils.isCruxTile(value)) {
                    this.renderCruxTile(tile, value, isNewTile);
                } else if (Utils.isSkillTile(value)) {
                    this.renderSkillTile(tile, value, isNewTile);
                } else {
                    this.renderGradeTile(tile, value, isNewTile);
                }
                
                return tile;
            },

            renderCruxTile(tile, cruxTile, isNewTile = false) {
                tile.className = 'tile crux';
                if (isNewTile) {
                    tile.classList.add('new-tile');
                }
                
                const icon = document.createElement('div');
                icon.className = 'crux-icon';
                icon.textContent = 'ğŸª¨';
                
                const counter = document.createElement('div');
                counter.className = 'crux-counter';
                counter.textContent = `-${cruxTile.remaining}í„´`;
                
                tile.appendChild(icon);
                tile.appendChild(counter);
            },
            
            renderSkillTile(tile, skillTile, isNewTile = false) {
                const skillType = Utils.getSkillType(skillTile);
                tile.className = `tile ${skillTile}`;
                if (isNewTile) {
                    tile.classList.add('new-tile');
                }
                
                const gradeDiv = document.createElement('div');
                gradeDiv.className = 'grade-text';
                gradeDiv.textContent = 'V7+';
                
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-text';
                skillDiv.textContent = this.getSkillDisplayText(skillType);
                
                tile.appendChild(gradeDiv);
                tile.appendChild(skillDiv);
            },
            
            renderGradeTile(tile, value, isNewTile = false) {
                tile.className = `tile ${CONFIG.GRADES[value]}`;
                if (isNewTile) {
                    tile.classList.add('new-tile');
                }
                tile.textContent = CONFIG.GRADE_NAMES[value];
            },
            
            getSkillDisplayText(skillType) {
                const skillTexts = {
                    grip: 'ê·¸ë¦½ë ¥',
                    core: 'ì½”ì–´',
                    dynamic: 'ë‹¤ì´ë‚˜ë¯¹',
                    balance: 'ë°¸ëŸ°ìŠ¤'
                };
                return skillTexts[skillType] || 'ìŠ¤í‚¬';
            },

            setupTileClickHandlers() {
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / CONFIG.BOARD_SIZE);
                    const col = index % CONFIG.BOARD_SIZE;
                    
                    tile.onclick = () => {
                        if (TileDeleteManager.isDeleteMode) {
                            TileDeleteManager.deleteTile(row, col);
                        }
                    };
                });
            },

            renderWithNewTileAnimation(board, newTilePositions) {
                const boardElement = document.getElementById('game-board');
                boardElement.innerHTML = '';
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const isNewTile = newTilePositions.some(pos => pos.x === i && pos.y === j);
                        const tile = this.createTileElement(board[i][j], isNewTile);
                        boardElement.appendChild(tile);
                    }
                }
                this.setupTileClickHandlers();
            },

            removeNewTileMarkers() {
                const newTiles = document.querySelectorAll('.tile.new-tile');
                newTiles.forEach(tile => {
                    tile.classList.remove('new-tile');
                });
            }
        };

        // Game Logic
        const GameLogic = {
            canMerge(a, b) {
                if (a === 0 || b === 0) return false;
                if (Utils.isSkillTile(a) || Utils.isSkillTile(b)) return false;
                if (Utils.isCruxTile(a) || Utils.isCruxTile(b)) return false;
                return a === b && a >= 1 && a <= CONFIG.MAX_MERGEABLE_VALUE;
            },
            
            processLine(line) {
                let newLine = [];
                let cruxPositions = [];
                
                for (let i = 0; i < line.length; i++) {
                    if (Utils.isCruxTile(line[i])) {
                        cruxPositions.push({pos: i, tile: line[i]});
                    }
                }
                
                let movableTiles = line.filter(cell => !Utils.isCruxTile(cell) && cell !== 0);
                let moved = false;
                let merges = 0;
                
                for (let i = 0; i < movableTiles.length - 1; i++) {
                    if (this.canMerge(movableTiles[i], movableTiles[i + 1])) {
                        const mergedValue = movableTiles[i] + 1;
                        movableTiles[i] = mergedValue;
                        movableTiles.splice(i + 1, 1);
                        merges++;
                        moved = true;
                    }
                }
                
                newLine = new Array(CONFIG.BOARD_SIZE).fill(0);
                
                cruxPositions.forEach(crux => {
                    newLine[crux.pos] = crux.tile;
                });
                
                let insertIndex = 0;
                for (let tile of movableTiles) {
                    while (insertIndex < CONFIG.BOARD_SIZE && newLine[insertIndex] !== 0) {
                        insertIndex++;
                    }
                    if (insertIndex < CONFIG.BOARD_SIZE) {
                        newLine[insertIndex] = tile;
                        insertIndex++;
                    }
                }
                
                if (JSON.stringify(line) !== JSON.stringify(newLine)) {
                    moved = true;
                }
                
                return { line: newLine, moved, merges };
            },
            
            moveBoard(board, direction) {
                let moved = false;
                let totalMerges = 0;
                
                if (direction === 'left') {
                    for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                        const result = this.processLine(board[i]);
                        board[i] = result.line;
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                } else if (direction === 'right') {
                    for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                        const result = this.processLine([...board[i]].reverse());
                        board[i] = result.line.reverse();
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                } else if (direction === 'up') {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const column = [board[0][j], board[1][j], board[2][j], board[3][j]];
                        const result = this.processLine(column);
                        for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                            board[i][j] = result.line[i];
                        }
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                } else if (direction === 'down') {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const column = [board[0][j], board[1][j], board[2][j], board[3][j]];
                        const result = this.processLine([...column].reverse());
                        const newColumn = result.line.reverse();
                        for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                            board[i][j] = newColumn[i];
                        }
                        if (result.moved) moved = true;
                        totalMerges += result.merges;
                    }
                }
                
                return { moved, merges: totalMerges };
            },
            
            hasAvailableMoves(board) {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (board[i][j] === 0) return true;
                    }
                }
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const current = board[i][j];
                        if (Utils.isCruxTile(current)) continue;
                        if (i < 3 && this.canMerge(current, board[i + 1][j])) return true;
                        if (j < 3 && this.canMerge(current, board[i][j + 1])) return true;
                    }
                }
                
                return false;
            }
        };

        // Bonus Card Manager
        const BonusCardManager = {
            currentBonus: null,
            isCardOpen: false,

            getBonusInfo(bonusType) {
                const bonusInfos = {
                    bonus_hold: {
                        icon: 'ğŸ§—â€â™‚ï¸',
                        title: 'ë³´ë„ˆìŠ¤ í™€ë“œ!',
                        description: 'V5 í™€ë“œê°€ ë¬´ì‘ìœ„ ìœ„ì¹˜ì— ìƒì„±ë©ë‹ˆë‹¤!'
                    },
                    tile_delete: {
                        icon: 'ğŸ—‘ï¸',
                        title: 'í™€ë“œ(íƒ€ì¼) ì‚­ì œ ì¹´ë“œ!',
                        description: 'ë§ˆìŒì— ì•ˆ ë“œëŠ” í™€ë“œë¥¼ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!'
                    },
                    shuffle_card: {
                        icon: 'ğŸ²',
                        title: 'ë¬´ì‘ìœ„ ì¬ë°°ì¹˜ ì¹´ë“œ!',
                        description: 'ë¬´ì‘ìœ„ë¡œ ê²Œì„ íƒ€ì¼ì„ ì„ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤<br>(ë‚˜ì¤‘ì— ì‚¬ìš© ê°€ëŠ¥)'
                    },
                    crux: {
                        icon: 'ğŸª¨',
                        title: 'í¬ëŸ­ìŠ¤!',
                        description: '3í„´ ë™ì•ˆ ì›€ì§ì´ì§€ ì•ŠëŠ” ë°”ìœ„ê°€ ìƒì„±ë©ë‹ˆë‹¤!'
                    }
                };
                return bonusInfos[bonusType] || bonusInfos.bonus_hold;
            },

            showReceiveCard() {
                document.getElementById('bonus-card-receive').style.display = 'flex';
                this.isCardOpen = true;
            },

            hideReceiveCard() {
                document.getElementById('bonus-card-receive').style.display = 'none';
                this.isCardOpen = false;
            },

            showConfirmCard(bonusType) {
                const bonusDisplay = document.getElementById('bonus-card-confirm');
                const icon = document.getElementById('bonus-card-icon');
                const title = document.getElementById('bonus-card-title');
                const description = document.getElementById('bonus-card-description');
                const question = document.getElementById('bonus-card-question');
                const actions = document.getElementById('bonus-card-actions');

                const bonusInfo = this.getBonusInfo(bonusType);
                icon.textContent = bonusInfo.icon;
                title.textContent = bonusInfo.title;
                description.innerHTML = bonusInfo.description;
                
                if (bonusType === 'crux') {
                    question.textContent = 'í¬ëŸ­ìŠ¤ê°€ ìë™ìœ¼ë¡œ ë°œë™ë©ë‹ˆë‹¤!';
                    actions.style.display = 'none';
                    setTimeout(() => {
                        this.addCrux();
                        this.hideConfirmCard();
                        this.currentBonus = null;
                    }, 2000);
                } else {
                    question.textContent = 'ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
                    actions.style.display = 'flex';
                }

                bonusDisplay.style.display = 'flex';
                this.isCardOpen = true;
            },

            hideConfirmCard() {
                const bonusDisplay = document.getElementById('bonus-card-confirm');
                const actions = document.getElementById('bonus-card-actions');
                
                if (bonusDisplay) {
                    bonusDisplay.style.display = 'none';
                }
                if (actions) {
                    actions.style.display = 'flex';
                }
                this.isCardOpen = false;
            },

            openCard() {
                this.hideReceiveCard();
                if (this.currentBonus) {
                    this.showConfirmCard(this.currentBonus);
                }
            },

            discardCard() {
                this.hideReceiveCard();
                this.currentBonus = null;
                UI.showAchievement('ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ ë²„ë ¸ìŠµë‹ˆë‹¤.');
            },

            confirmUse() {
                if (!this.currentBonus) return;

                switch (this.currentBonus) {
                    case 'bonus_hold':
                        this.addBonusHold();
                        break;
                    case 'tile_delete':
                        TileDeleteManager.startDeleteMode();
                        break;
                    case 'shuffle_card':
                        ShuffleManager.giveShuffleCard();
                        break;
                    case 'crux':
                        break;
                }

                if (this.currentBonus !== 'tile_delete' && this.currentBonus !== 'crux') {
                    this.hideConfirmCard();
                    this.currentBonus = null;
                }
            },

            declineUse() {
                this.hideConfirmCard();
                this.currentBonus = null;
                UI.showAchievement('ë³´ë„ˆìŠ¤ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            },

            showRandomBonus() {
                const bonusTypes = CONFIG.BONUS_TYPES;
                const randomIndex = Math.floor(Math.random() * bonusTypes.length);
                this.currentBonus = bonusTypes[randomIndex];
                this.showReceiveCard();
            },

            addBonusHold() {
                const emptyCells = Utils.getEmptyCells(Game.board);
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    Game.board[randomCell.x][randomCell.y] = 6; // V5
                    UI.showAchievement('ë³´ë„ˆìŠ¤ V5 í™€ë“œ ìƒì„±!');
                    RenderManager.renderWithNewTileAnimation(Game.board, [{x: randomCell.x, y: randomCell.y}]);
                }
            },

            addCrux() {
                const emptyCells = Utils.getEmptyCells(Game.board);
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    Game.board[randomCell.x][randomCell.y] = {
                        type: 'crux',
                        remaining: 3
                    };
                    UI.showAchievement('í¬ëŸ­ìŠ¤ ìƒì„±! 3í„´ í›„ ì‚¬ë¼ì§‘ë‹ˆë‹¤');
                    RenderManager.renderWithNewTileAnimation(Game.board, [{x: randomCell.x, y: randomCell.y}]);
                }
            }
        };

        // Tile Delete Manager
        const TileDeleteManager = {
            isDeleteMode: false,

            startDeleteMode() {
                BonusCardManager.hideConfirmCard();
                this.enableDeleteMode();
                this.isDeleteMode = true;
                BonusCardManager.currentBonus = null;
            },

            enableDeleteMode() {
                document.getElementById('tile-delete-mode').style.display = 'flex';
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / CONFIG.BOARD_SIZE);
                    const col = index % CONFIG.BOARD_SIZE;
                    const tileValue = Game.board[row][col];
                    
                    if (Utils.isDeletableTile(tileValue)) {
                        tile.classList.add('clickable');
                    }
                });
                BonusCardManager.isCardOpen = true;
            },

            disableDeleteMode() {
                document.getElementById('tile-delete-mode').style.display = 'none';
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach(tile => {
                    tile.classList.remove('clickable');
                });
                BonusCardManager.isCardOpen = false;
            },

            deleteTile(row, col) {
                if (this.isDeleteMode && Utils.isDeletableTile(Game.board[row][col])) {
                    Game.board[row][col] = 0;
                    UI.showAchievement('íƒ€ì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
                    RenderManager.renderBoard(Game.board);
                    this.cancel();
                }
            },

            cancel() {
                this.isDeleteMode = false;
                this.disableDeleteMode();
            }
        };

        // Shuffle Manager
        const ShuffleManager = {
            giveShuffleCard() {
                Game.hasShuffle = true;
                this.showShuffleButton();
                UI.showAchievement('ë¬´ì‘ìœ„ ì¬ë°°ì¹˜ ì¹´ë“œ íšë“!');
            },

            showShuffleButton() {
                document.getElementById('shuffle-btn').style.display = 'inline-block';
            },

            hideShuffleButton() {
                document.getElementById('shuffle-btn').style.display = 'none';
            },

            shuffle() {
                if (Game.hasShuffle) {
                    const tiles = [];
                    const positions = [];
                    
                    for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                        for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                            if (Game.board[i][j] !== 0) {
                                tiles.push(Game.board[i][j]);
                                positions.push({x: i, y: j});
                            }
                        }
                    }
                    
                    // Fisher-Yates shuffle
                    for (let i = tiles.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                    }
                    
                    // Clear board
                    for (let pos of positions) {
                        Game.board[pos.x][pos.y] = 0;
                    }
                    
                    // Place shuffled tiles
                    for (let i = 0; i < tiles.length; i++) {
                        const pos = positions[i];
                        Game.board[pos.x][pos.y] = tiles[i];
                    }
                    
                    Game.hasShuffle = false;
                    this.hideShuffleButton();
                    UI.showAchievement('íƒ€ì¼ì´ ë¬´ì‘ìœ„ë¡œ ì¬ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    
                    RenderManager.renderBoard(Game.board);
                }
            }
        };

        // Main Game Class
        class BoulderMasterGame {
            constructor() {
                this.board = Utils.createEmptyBoard();
                this.gameOver = false;
                this.moveCount = 0;
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem(CONFIG.STORAGE_KEY) || '0');
                this.hasShuffle = false;
                this.bonusCardEnabled = true;
                
                this.skills = {
                    grip: false,
                    core: false,
                    dynamic: false,
                    balance: false
                };
                this.skillCount = 0;
                this.initialized = false;
            }
            
            init() {
                if (!this.initialized) {
                    this.addRandomTile();
                    this.addRandomTile();
                    this.initialized = true;
                }
                this.updateDisplay();
                RenderManager.renderBoard(this.board);
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.removeEventListeners();

                this.keydownHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    
                    const keyActions = {
                        'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                        'ArrowDown': 'down', 's': 'down', 'S': 'down',
                        'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                        'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                    };
                    
                    const direction = keyActions[e.key];
                    if (direction) {
                        e.preventDefault();
                        this.handleMove(direction);
                    }
                };
                
                document.addEventListener('keydown', this.keydownHandler);

                this.setupTouchEvents();
                this.setupMouseEvents();
            }

            setupTouchEvents() {
                this.touchStartX = 0;
                this.touchStartY = 0;

                const gameContainer = document.getElementById('game-container');
                
                this.touchStartHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    
                    if (e.target.closest('.btn')) {
                        this.touchStartX = null;
                        this.touchStartY = null;
                        return;
                    }

                    const touch = e.touches[0] || e.changedTouches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                };

                this.touchMoveHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    e.preventDefault();
                };

                this.touchEndHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    
                    if (this.touchStartX === null || this.touchStartY === null) {
                        return;
                    }

                    e.preventDefault();
                    
                    const touch = e.changedTouches[0];
                    const touchEndX = touch.clientX;
                    const touchEndY = touch.clientY;
                    
                    this.handleSwipe(this.touchStartX, this.touchStartY, touchEndX, touchEndY);
                };

                gameContainer.addEventListener('touchstart', this.touchStartHandler, { passive: false });
                gameContainer.addEventListener('touchmove', this.touchMoveHandler, { passive: false });
                gameContainer.addEventListener('touchend', this.touchEndHandler, { passive: false });
            }

            setupMouseEvents() {
                this.mouseStartX = 0;
                this.mouseStartY = 0;
                this.isMouseDown = false;

                const gameBoard = document.getElementById('game-board');

                this.mouseDownHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || TileDeleteManager.isDeleteMode) return;
                    e.preventDefault();
                    this.isMouseDown = true;
                    this.mouseStartX = e.clientX;
                    this.mouseStartY = e.clientY;
                };

                this.mouseUpHandler = (e) => {
                    if (this.gameOver || BonusCardManager.isCardOpen || !this.isMouseDown || TileDeleteManager.isDeleteMode) return;
                    e.preventDefault();
                    this.isMouseDown = false;
                    const mouseEndX = e.clientX;
                    const mouseEndY = e.clientY;
                    this.handleSwipe(this.mouseStartX, this.mouseStartY, mouseEndX, mouseEndY);
                };

                this.mouseLeaveHandler = () => {
                    this.isMouseDown = false;
                };

                gameBoard.addEventListener('mousedown', this.mouseDownHandler);
                gameBoard.addEventListener('mouseup', this.mouseUpHandler);
                gameBoard.addEventListener('mouseleave', this.mouseLeaveHandler);
            }

            removeEventListeners() {
                if (this.keydownHandler) {
                    document.removeEventListener('keydown', this.keydownHandler);
                }
                
                const gameContainer = document.getElementById('game-container');
                const gameBoard = document.getElementById('game-board');
                
                if (this.touchStartHandler) {
                    gameContainer.removeEventListener('touchstart', this.touchStartHandler);
                }
                if (this.touchMoveHandler) {
                    gameContainer.removeEventListener('touchmove', this.touchMoveHandler);
                }
                if (this.touchEndHandler) {
                    gameContainer.removeEventListener('touchend', this.touchEndHandler);
                }
                if (this.mouseDownHandler) {
                    gameBoard.removeEventListener('mousedown', this.mouseDownHandler);
                }
                if (this.mouseUpHandler) {
                    gameBoard.removeEventListener('mouseup', this.mouseUpHandler);
                }
                if (this.mouseLeaveHandler) {
                    gameBoard.removeEventListener('mouseleave', this.mouseLeaveHandler);
                }
            }

            handleSwipe(startX, startY, endX, endY) {
                const minSwipeDistance = 50;
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                    return;
                }
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 0) {
                        this.handleMove('right');
                    } else {
                        this.handleMove('left');
                    }
                } else {
                    if (deltaY > 0) {
                        this.handleMove('down');
                    } else {
                        this.handleMove('up');
                    }
                }
            }

            handleMove(direction) {
                RenderManager.removeNewTileMarkers();
                
                const boardBefore = Utils.deepCopyBoard(this.board);
                const result = GameLogic.moveBoard(this.board, direction);
                
                if (result.moved) {
                    this.moveCount++;
                    
                    Utils.processCruxTiles(this.board);
                    
                    this.convertV7ToSkill();
                    this.calculateScore(result);
                    this.processSkillAcquisition();
                    
                    const emptyCellsBefore = Utils.getEmptyCells(this.board);
                    this.addRandomTile();
                    const emptyCellsAfter = Utils.getEmptyCells(this.board);
                    
                    const newTilePositions = this.findNewTilePositions(emptyCellsBefore, emptyCellsAfter);
                    
                    this.updateDisplay();
                    RenderManager.renderWithNewTileAnimation(this.board, newTilePositions);
                    
                    if (this.bonusCardEnabled && this.moveCount % CONFIG.BONUS_INTERVAL === 0) {
                        setTimeout(() => {
                            BonusCardManager.showRandomBonus();
                        }, 500);
                    }
                    
                    this.checkGameState();
                }
            }

            findNewTilePositions(emptyCellsBefore, emptyCellsAfter) {
                const newPositions = [];
                
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const wasEmpty = emptyCellsBefore.some(cell => cell.x === i && cell.y === j);
                        const isEmptyNow = emptyCellsAfter.some(cell => cell.x === i && cell.y === j);
                        
                        if (wasEmpty && !isEmptyNow) {
                            newPositions.push({x: i, y: j});
                        }
                    }
                }
                
                return newPositions;
            }

            calculateScore(result) {
                if (result.merges > 1) {
                    const comboBonus = result.merges * 100;
                    UI.showAchievement(`${result.merges}ì—°ì† ì™„ë“±! +${comboBonus}`);
                    this.addScore(comboBonus);
                }
            }

            addScore(points) {
                this.score += points;
                this.updateBestScore();
                UI.updateScore(this.score);
            }

            updateBestScore() {
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem(CONFIG.STORAGE_KEY, this.bestScore.toString());
                    UI.updateBestScore(this.bestScore);
                }
            }
            
            processSkillAcquisition() {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        const cell = this.board[i][j];
                        if (Utils.isSkillTile(cell)) {
                            const skillType = Utils.getSkillType(cell);
                            if (this.acquireSkill(skillType)) {
                                this.addScore(500);
                            }
                        }
                    }
                }
            }

            acquireSkill(skillType) {
                if (!this.skills[skillType]) {
                    this.skills[skillType] = true;
                    UI.showAchievement(`${CONFIG.SKILL_NAMES[skillType]} ìŠ¤í‚¬ íšë“!`);
                    UI.updateSkillsDisplay(this.skills);
                    return true;
                }
                return false;
            }

            hasAllSkills() {
                return Object.values(this.skills).every(skill => skill);
            }

            convertV7ToSkill() {
                for (let i = 0; i < CONFIG.BOARD_SIZE; i++) {
                    for (let j = 0; j < CONFIG.BOARD_SIZE; j++) {
                        if (this.board[i][j] === CONFIG.V7_VALUE && this.skillCount < 4) {
                            const skillTile = this.generateSkillTile();
                            if (typeof skillTile === 'string') {
                                this.board[i][j] = skillTile;
                                this.skillCount++;
                            }
                        }
                    }
                }
            }

            generateSkillTile() {
                if (this.skillCount < 4) {
                    return `skill-${CONFIG.SKILL_TYPES[this.skillCount]}`;
                }
                return CONFIG.V7_VALUE;
            }
            
            addRandomTile() {
                const emptyCells = Utils.getEmptyCells(this.board);
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.board[randomCell.x][randomCell.y] = Utils.getRandomTile();
                }
            }
            
            checkGameState() {
                if (this.hasAllSkills()) {
                    setTimeout(() => this.endGame(true), 500);
                    return;
                }
                
                if (!GameLogic.hasAvailableMoves(this.board)) {
                    this.gameOver = true;
                    setTimeout(() => this.endGame(false), 300);
                }
            }
            
            endGame(won) {
                this.gameOver = true;
                UI.showGameOver(won, this.score);
            }

            newGame() {
                this.board = Utils.createEmptyBoard();
                this.gameOver = false;
                this.moveCount = 0;
                this.score = 0;
                this.hasShuffle = false;
                
                this.skills = {
                    grip: false,
                    core: false,
                    dynamic: false,
                    balance: false
                };
                this.skillCount = 0;
                
                // Reset managers
                TileDeleteManager.isDeleteMode = false;
                BonusCardManager.isCardOpen = false;
                BonusCardManager.currentBonus = null;
                
                // Hide all modals and overlays
                UI.hideGameOver();
                ShuffleManager.hideShuffleButton();
                TileDeleteManager.disableDeleteMode();
                BonusCardManager.hideReceiveCard();
                BonusCardManager.hideConfirmCard();
                
                this.addRandomTile();
                this.addRandomTile();
                this.updateDisplay();
                RenderManager.renderBoard(this.board);
            }
            
            updateDisplay() {
                UI.updateScore(this.score);
                UI.updateBestScore(this.bestScore);
                UI.updateMoveCount(this.moveCount);
                UI.updateSkillsDisplay(this.skills);
            }
        }

        // Game Controller
        const GameController = {
            game: null,

            startGame() {
                const bonusCardEnabled = document.getElementById('bonus-card-enabled').checked;
                
                UI.hideMainMenu();
                UI.hideGuide();
                
                if (!this.game) {
                    this.game = new BoulderMasterGame();
                }
                
                this.game.bonusCardEnabled = bonusCardEnabled;
                this.game.init();
            },

            newGame() {
                if (this.game) {
                    this.game.newGame();
                } else {
                    this.game = new BoulderMasterGame();
                    this.game.init();
                }
            }
        };

        // Global Game Instance (for backward compatibility)
        let Game = null;

        // Initialize Game Reference
        function initializeGameReference() {
            if (GameController.game) {
                Game = GameController.game;
            }
        }

        // Override GameController methods to update global reference
        const originalStartGame = GameController.startGame;
        const originalNewGame = GameController.newGame;

        GameController.startGame = function() {
            originalStartGame.call(this);
            initializeGameReference();
        };

        GameController.newGame = function() {
            originalNewGame.call(this);
            initializeGameReference();
        };

        // Initialize on page load
        window.addEventListener('load', () => {
            const bestScore = parseInt(localStorage.getItem(CONFIG.STORAGE_KEY) || '0');
            UI.updateBestScore(bestScore);
            
            // PWA ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡
            PWAManager.init();
        });

        // PWA Manager
        const PWAManager = {
            init() {
                this.registerServiceWorker();
                this.setupInstallPrompt();
                this.addToHomeScreenPrompt();
            },

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker ë“±ë¡ ì„±ê³µ:', registration);
                    } catch (error) {
                        console.log('Service Worker ë“±ë¡ ì‹¤íŒ¨:', error);
                    }
                }
            },

            setupInstallPrompt() {
                let deferredPrompt;

                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    deferredPrompt = e;
                    this.showInstallButton(deferredPrompt);
                });

                window.addEventListener('appinstalled', () => {
                    console.log('PWAê°€ ì„¤ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    this.hideInstallButton();
                });
            },

            showInstallButton(deferredPrompt) {
                // ì„¤ì¹˜ ë²„íŠ¼ì„ ë©”ì¸ ë©”ë‰´ì— ì¶”ê°€
                const openingButtons = document.querySelector('.opening-buttons');
                if (openingButtons && !document.getElementById('install-btn')) {
                    const installBtn = document.createElement('button');
                    installBtn.id = 'install-btn';
                    installBtn.className = 'btn warning';
                    installBtn.innerHTML = 'ğŸ“± ì•±ìœ¼ë¡œ ì„¤ì¹˜í•˜ê¸°';
                    installBtn.onclick = () => this.installApp(deferredPrompt);
                    
                    // ê°€ì´ë“œ ë²„íŠ¼ ì•ì— ì¶”ê°€
                    const guideBtn = openingButtons.querySelector('button:last-child');
                    openingButtons.insertBefore(installBtn, guideBtn);
                }
            },

            hideInstallButton() {
                const installBtn = document.getElementById('install-btn');
                if (installBtn) {
                    installBtn.remove();
                }
            },

            async installApp(deferredPrompt) {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('ì„¤ì¹˜ ê²°ê³¼:', outcome);
                    deferredPrompt = null;
                    this.hideInstallButton();
                }
            },

            addToHomeScreenPrompt() {
                // iOS Safariìš© ì„¤ì¹˜ ì•ˆë‚´
                if (this.isIOS() && !this.isInStandaloneMode()) {
                    setTimeout(() => {
                        if (!localStorage.getItem('ios-install-prompt-shown')) {
                            UI.showAchievement('Safariì—ì„œ "í™ˆ í™”ë©´ì— ì¶”ê°€"ë¡œ ì•±ì²˜ëŸ¼ ì‚¬ìš©í•˜ì„¸ìš”!');
                            localStorage.setItem('ios-install-prompt-shown', 'true');
                        }
                    }, 3000);
                }
            },

            isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent);
            },

            isInStandaloneMode() {
                return window.matchMedia('(display-mode: standalone)').matches ||
                       window.navigator.standalone === true;
            }
        };
    </script>
</body>
</html>
